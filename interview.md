Q # 1) DevOps를 설명하십시오.

대답:

DevOps는 비즈니스, 개발 및 운영 팀 간의 커뮤니케이션 및 협업을 촉진합니다. 어떤 의미에서 우리는 통일에 대해 이야기하고 있습니다.
DevOps는 도구에 관한 것이 아니라 사람과 프로세스를 포함하는 것입니다.
DevOps는 Agile 프로세스에서 영감을 받았습니다.
DevOps는 개발, 릴리스 및 운영 프로세스를 자동화하는 것입니다.
DevOps는 최종 사용자에게 애플리케이션을 제공하는 속도를 지원합니다.
DevOps는 또한 피드백을 통해 학습하는 데 도움이되는 지속적인 개선에 관한 것입니다.
Q # 2) DevOps 구현에 유용한 몇 가지 전제 조건을 설명하십시오.

답변 : 전제 조건에는 다음이 포함됩니다.

조직의 고위급에서의 헌신.
조직 전체에 변화를 전달할 필요가 있습니다.
버전 관리 소프트웨어.
프로세스 준수를위한 자동화 도구.
자동화 된 테스트
자동화 된 배포
Q # 3) DevOps 구현을위한 모범 사례는 무엇입니까?

대답: DevOps 구현은 조직마다 다릅니다. 오늘날 조직은 소프트웨어를 더 빨리 제공하기를 원하고 있으며 여기에서 DevOps가 운영 팀을 포함한 모든 이해 관계자와 효율적인 커뮤니케이션을 가능하게하는 방법에 대한 저의 생각이 있습니다.

모든 조직에는 특정 비즈니스 목표가 있으며 DevOps 구현은 이에 맞춰야합니다. 변화가 필요합니다.
특히 개발과 운영 간의 커뮤니케이션 및 협업을 장려합니다.
자동화가 핵심이며 DevOps의 작업을 용이하게하기 위해 SDLC 단계 내에서 가능한 한 수행되고 수행되어야합니다.
DevOps에서 사용되는 도구는 매우 잘 통합되어야합니다. IBM Rational CLM 또는 Microsoft TFS와 같은 상용 도구의 관점에서 볼 때 DevOps 구현은 단일 공급 업체에서 제공하는 것처럼 훌륭합니다. 마찬가지로, 유사한 원하는 결과를 제공하기 위해 통합되는 오픈 소스 도구를 살펴볼 필요가 있습니다.
지속적 통합 및 지속적 배포 관행 없이는 DevOps 구현이 성공하지 못합니다. 따라서 엄격한 테스트 및 CD 작업을 통해 코드의 CI가 핵심입니다.
Ops 팀은 애플리케이션이 적절한 수준에서 매우 잘 작동하는지 확인하는 것이 매우 중요합니다. 필요한 경우 애플리케이션에 올바른 모니터링 기능을 구축하는 데 도움이되는 도구를 구축하기 위해 개발 팀과 협력해야합니다.
마지막으로, 최종 사용자의 피드백을 장려하여 프로세스를 개선하고 양질의 소프트웨어를 제공하기위한 핵심을 제공하는 지속적인 개선을 가능하게합니다.
Q # 4) DevOps의 주요 구성 요소는 무엇입니까?

답변 : 주요 구성 요소는 다음과 같습니다.

지속적인 통합
지속적인 테스트
지속적인 전달
지속적인 모니터링
Q # 5) 지속적인 통합을 설명하십시오.

대답: 지속적인 통합은 Agile 프로세스에서 매우 중요한 구성 요소입니다. 일반적으로 개발자는 스프린트 내에서 기능 또는 사용자 스토리에 대해 작업하고 변경 사항을 버전 제어 저장소에 커밋합니다.

코드가 커밋되면 개발자의 전체 작업이 잘 통합되고 모든 체크인 또는 일정에 따라 정기적으로 빌드가 수행됩니다. 따라서 지속적 통합을 실행하면 개발자가 변경 사항을 다른 사용자와 통합하여 조기 피드백을받을 수 있습니다.

Q # 6) 지속적인 배포를 설명하십시오.

PC 청소를위한 최고의 무료 소프트웨어
대답: Continuous Delivery는 개발자가 개발중인 기능을 가능한 한 빨리 최종 사용자에게 제공하는 데 주로 도움이되는 지속적 통합의 확장입니다. 이 과정에서 다양한 단계의 QA, Staging 등을 거쳐 PRODUCTION 시스템으로 전달됩니다.

Q # 7) 연속 테스트를 설명하십시오.

대답: 애플리케이션을 최종 사용자에게 제공하는 위의 지속적 통합 목표에서 주로 지속적 제공을 가능하게합니다. 이는 충분한 단위 테스트와 자동화 테스트 없이는 완료 될 수 없습니다.

따라서 코드가 생성되고 필요에 따라 수행하는 모든 개발자와 통합되었는지 검증해야합니다.

Q # 8) 지속적인 모니터링을 설명하십시오.

대답: 응용 프로그램이 개발되고 배포됨에 따라 성능을 모니터링해야합니다. 모니터링 또한 이전에 발견되지 않았을 수있는 결함을 발견하는 데 도움이 될 수 있으므로 매우 중요합니다.

Q # 9) 프로젝트에서 DevOps를 구현해야 할 때 어떻게 접근 하시겠습니까?

답변 : 다음 접근 방식을 사용할 수 있지만 실제 프로젝트 시나리오에 따라 또는 조직마다 다를 수 있습니다.

스테이지 1: 모든 DevOps 구현의 경우 평균 5 개의 애플리케이션을 사용하여 약 2 ~ 3 주 동안 기존 프로세스 및 구현에 대한 평가는 AS-IS 프로세스를 측정하고 개선 영역을 식별하며 구현을위한 로드맵을 제공하는 데 필수적입니다.

일반적으로 DevOps 설계자와 같은 고위 프로필이이 평가를 수행해야합니다.

2 단계 : DevOps의 종단 간 작업을 보여주기 위해 파일럿 POC를 수행 할 수 있습니다. 최종 사용자가이를 수락하고 승인 한 후에 만 ​​실제 구현, 관련된 프로젝트에 대한 계획을 전달 및 배포해야합니다.

필요한 교육도 프로세스 또는 도구에 전달해야합니다. DevOps 설계자, 엔지니어 및 테스터가이 단계에 참여해야합니다.

기본 게이트웨이를 사용할 수 없음 Windows 10 WiFi
3 단계 : 이제 프로젝트는 계속되는 통합 / 배달 / 테스트 및 모니터링의 모든 구성 요소와 함께 DevOps 모드에 있어야합니다.

Q # 10) DevOps를 Waterfall 프로세스에 적용 할 수 있습니까? DevOps 구현에서 Agile 프로세스의 중요성을 설명합니다.

대답: 폭포수 프로세스에서 우리 모두는 처음에 완전한 요구 사항이 수집되고 다음으로 시스템이 설계되고 시스템 구현이 완료된 다음 시스템 테스트가 완료되고 최종 사용자에게 배포됨을 알고 있습니다. 이 과정에서 문제는 빌드 및 배포를위한 대기 시간이 길어서 피드백을 받기가 매우 어려웠습니다.

위의 문제에 대한 해결책은 Agile 프로세스가 개발과 운영 모두에서 민첩성을 가져와야한다는 것입니다. 애자일 프로세스가 주체이거나 DevOps 구현을 위해 특정 전제 조건이 필요할 수 있습니다. DevOps는 Agile 프로세스와 함께 진행됩니다.

초점 영역은 짧은 릴리스주기와 빠른 피드백으로 매우 적시에 소프트웨어를 릴리스하는 것입니다. 따라서 애자일 프로세스의 초점은 주로 속도에 있으며 DevOps에서는 다양한 도구의 자동화와 잘 작동합니다.

Q # 11) 지속적 배포와 지속적 배포의 차이점은 무엇입니까?

대답: 애자일 스프린트에서 예를 들어, 개발, 테스트 및 배포 할 준비가 된 많은 기능 또는 사용자 스토리가 있습니다. 그러나 고객 시나리오와 우선 순위에 따라 모든 것이 배포되는 것은 아닙니다. 따라서 여기서 지속적인 배포에서는 코드를 배포 할 수 있도록 쉽게 유지하는 것이 매우 중요합니다.

Continous Deployment에서 개발자가 개발 한 모든 변경 사항은 자동화 된 방식으로 PRODUCTION 환경에 배포하기 위해 다양한 단계를 거칩니다.

Q # 12) DevOps 프로젝트에 대한 전문 지식은 무엇입니까?

대답: DevOps 엔지니어로서의 역할과 CI 및 CD 파이프 라인을 자동화하고 프로젝트 팀에 지원을 제공하는 데 관련된 프로젝트에 대해 연중 무휴 환경의 일환으로 작업하는 방식과 교대 근무 방식을 설명하십시오.

따라서 DevOps 자동화를위한 환경을 유지 관리하고 점점 더 많은 프로젝트와 다양한 기술로 확장 할 책임이 있습니다 ( 예: .NET, J2EE 프로젝트)는 조직 내에 포함됩니다.

또한 프로세스 ( 예 Agile) 및 엔드 투 엔드 자동화에 관련된 도구. 클라우드 환경에서 DevOps 지원에 대한 경험 (있는 경우)에 대해서도 이야기 할 수 있습니다.

Q # 13) 오늘날 업계에서 사용되는 10 대 DevOps 도구는 무엇입니까?

답변 : 목록에는 다음이 포함됩니다.

Jira
GIT / SVN
Bitbucket
젠킨스
대나무
SonarQube
Artifactory / Nexus
Docker
요리사 / 인형 / Ansible
IBM Urbancode Deploy / CA-RA
Nagios / Splunk
Q # 14) 위 질문에서 언급 한 도구의 사용과 DevOps 모델 (CI / CD)을 제공하기 위해 연결하는 방법을 설명해 주시겠습니까?

대답:

계획

Jira – 프로젝트 기획 및 이슈 관리에 사용
지속적인 통합

가다 – 버전 관리
젠킨스 – Continuous Delivery에서도 도움이 될 수있는 오픈 소스 지속적 통합 도구.
SonarQube – 코드 분석
JFrog Artifactory – 바이너리 리포지토리 관리자
지속적인 전달

Chef / Puppet / Ansible – 구성 관리 및 애플리케이션 배포
IBM Urbancode Deploy / CA RA – 지속적인 전달
지속적인 모니터링

Nagios / Splunk
샘플 DevOps 워크 플로 :

Devops 워크 플로 샘플

일반적으로 Agile 프로세스에서는 사용자 스토리, 작업, 결함 등이 모두 JIRA에 저장되고 제품 소유자 및 개발자에게 할당됩니다.
개발자는 자신에게 할당 된 작업을 선택하고 개발 작업을합니다. 소스 코드는 버전 관리되고 GIT에 저장됩니다. 개발자는 GIT의 소스 코드에 대한 변경 사항을 커밋합니다. 결국 코드는 GitHub를 사용하는 개발자간에 공유됩니다.
지속적 통합 도구 인 Jenkins는 코드를 가져 와서 체크인 할 때마다 또는 일정에 따라 Maven 또는 ANT와 같은 빌드 도구를 사용하여 빌드를 수행합니다.
J2EE WAR 파일이 생성되면 버전이 제어되고 Artifactory 또는 Nexus와 같은 바이너리 저장소 관리자에 저장됩니다.
SonarQube와 함께 JUnit 및 코드 분석을 사용한 단위 테스트도 수행되고 자동화됩니다.
위의 프로세스가 완료되면 Selenium과 같은 도구를 사용하여 적절한 테스트 환경에서 IBM UrbanCode Deploy / CA RA Continuous Testing (기능 및 승인 테스트)과 같은 도구를 사용하여 승인을 기반으로 다양한 환경에 지속적 전달이 수행됩니다.
지속적인 모니터링은 PROD 환경에서 지속적인 활동입니다.


Q # 15) 인프라 측면에서 구성 관리 란 무엇이며 사용되는 몇 가지 인기 도구를 언급합니까?

대답: 구성 관리는 제공 및 인프라 운영을 자동화하는 데 관련된 다양한 도구와 사례로 구성됩니다. 서버를 준비하는 것입니다 ( 예 응용 프로그램이 개발되면 응용 프로그램 배포를위한 시스템 패키지 설치, 네트워크 구성 설정).

따라서 운영팀 또는 시스템 관리자는 시스템을 프로비저닝하여 다양한 환경 (Dev, QA, PROD 등)에서 패리티를 보장해야합니다.

위에서 설명한 구성 관리 작업을 자동화하기 위해이 공간에서 사용되는 도구는 다음과 같습니다. 셰프 / 퍼펫 / 앤서 블

Q # 16) DevOps에서 사용되는 스크립팅 도구는 무엇입니까?

대답: Python, Ruby

Q # 17) DevOps와 관련된 일반적인 역할을 설명하십시오.

대답:

DevOps 설계자 : 전체 DevOps 프로세스를 담당하는 리더입니다.
DevOps 엔지니어 : 그 사람은 Agile, SCM 또는 버전 제어, CI / CD 및 동일한 인프라 자동화 및 데이터베이스 관리 기술을위한 자동화 도구 설정에 대한 경험이 있어야합니다. 코딩 또는 스크립팅 기술이 있고 배포 또는 시스템 관리자에 대한 통찰력이있는 개발자는 DevOps 엔지니어의 역할을 수행 할 수 있습니다.
Q # 18) 클라우드에서 DevOps 구현에 참여 했습니까? 그렇다면 어떤 클라우드 컴퓨팅 플랫폼입니까?

대답:인기있는 클라우드 컴퓨팅 플랫폼의 예 :

AWS – Amazon Web Services
마이크로 소프트 애저
구글 클라우드
Q # 19) DevOps 성공을 위해 따랐던 몇 가지 지표를 설명하십시오.

대답:

몇 가지 예는 다음과 같습니다.

첫 번째이자 가장 중요한 요소는 작업 항목이 프로덕션 환경에 들어가는 데 걸리는 시간을 의미하는 전달 속도입니다.
다음은 배포와이 프로세스가 자동화 된 후 걸리는 시간입니다.
PRODUCTION 환경과 관련하여 서로 다른 환경에서 발견 된 결함 수를 추적하는 것이 거의 필요합니다. 이는 더 빨리 출시되어야하는 기능을 고려할 때 매우 중요합니다. Agile 방법론의 사용은 많은 도움이되며 주요 목표는 생산 수준의 결함을 줄이는 것입니다.
일반적으로 배포는 실패하지 않지만이 측면을 추적하고 이전 안정 버전으로 롤백하는 메커니즘을 갖는 것이 매우 중요합니다.
모든 DevOps 구현에서 단위 테스트는 기능 테스트이자 핵심입니다. 수행 된 코드 변경 사항을 기반으로 이러한 테스트가 어느 정도까지 중단되는지 살펴 봐야합니다. 자동화 된 테스트는 코드 변경 사항을 유지할 수있을만큼 강력해야합니다.
PRODUCTION 환경에서 장애가 발생한 경우 복구하는 데 걸리는 실제 또는 평균 시간을 측정하는 것은 매우 중요합니다. 이를 MTTR (평균 복구 시간)이라고하며 짧아야합니다. 이는 또한 복구 시간을 짧게 유지하기 위해 적절한 모니터링 도구가 필요함을 의미합니다.
응용 프로그램의 성능은 특히 배포가 완료된 후 모니터링해야하는 또 다른 주요 지표입니다.
성공을위한 매우 중요한 요소는 주로 애플리케이션의 품질에 따라 달라지는 고객이보고하는 버그의 수입니다.


Q # 20) DevOps의 경력 관점에서 기대하는 것은 무엇입니까?

Java로 열리도록 Jar 파일을 설정하는 방법
대답: 개발 및 운영 팀이 협력하고 서로의 관점을 이해할 수 있도록 종단 간 제공 프로세스 및 프로세스 개선을 돕는 가장 중요한 측면에 참여합니다.

결론
이것이 가장 인기있는 DevOps 인터뷰 질문 목록입니다.

시작 부분 이 일련의 DevOps 자습서 , 우리는 DevOps가 정확히 무엇인지, 프로세스 및이를 구현할 수있는 특정 방법을 알게되었습니다.

이 자습서의 DevOps 질문은 DevOps 인터뷰를 정복하고이 분야에서 훌륭한 경력을 쌓는 데 도움이되기를 바랍니다. 언급 된 질문은 DevOps 관점에서 나온 것이므로 CI 및 CD에 대한이 기사에서 언급 한 Agile 프로세스와 도구에 능숙해야합니다.

DevOps 시리즈의 모든 자습서를 즐겼기를 바랍니다. DevOps 개념에 대한 방대한 지식을 얻었을 것입니다 !! 모든 성공을 기원합니다 !!!

---


1. DevOps와 Agile의 차이점은 무엇입니까?
이것은 더 쉬운 DevOps 인터뷰 질문 중 하나처럼 보이지만 특정 핵심 사항을 염두에 두어야 합니다. DevOps와 Agile의 주요 차이점은 다음과 같습니다.

|특징|데브옵스|기민한|
|--|--|--|
|특징|데브옵스|에자일|
|민첩|개발 및 운영 모두에 존재|개발 중인 경우에만 표시|
|프로세스|CI, CD 및 CT와 같은 프로세스가 포함| Agile Scrum, Agile Kanban 등과 같은 관행 포함|
|초점 영역| 적시성과 품질은 동등하게 우 정시성이 최우선|동일|
|피드백 출처| 자체 모니터링 도구에서 제공 고객의 피드백 하는 피드백|동일|
|업무 범위| 민첩성 및 자동화 필요| 민첩성만 필요|


2. DevOps가 필요한 이유는 무엇입니까?
이 DevOps 인터뷰 질문에 대한 응답은 일반적인 시장 동향에 대한 설명으로 시작해야 합니다. 기업은 작은 기능이 고객에게 빠르게 전달될 수 있는지 확인하려고 노력하고 있습니다. 고객의 빠른 피드백과 더 나은 소프트웨어 품질과 같은 여러 이점이 있어 고객 만족도가 높기 때문입니다.

이를 달성하기 위해 기업은 배포 빈도를 높이고 새 릴리스의 실패율을 낮추고 수정 간의 리드 타임을 단축하고 새 릴리스가 충돌하는 경우 평균 복구 시간을 단축해야 합니다.

DevOps는 이러한 모든 요구 사항을 충족하고 원활한 소프트웨어 제공을 제공합니다. Etsy, Google 및 Amazon은 몇 년 전만 해도 상상할 수 없었던 수준의 성능을 달성하기 위해 DevOps를 채택한 일부 회사의 예입니다.

이러한 수십억 달러 규모의 기업은 세계 최고 수준의 안정성, 안정성 및 보안을 제공하면서 매일 수천 개의 코드 배포를 실행합니다.

3. DevOps의 핵심 측면 또는 원칙은 무엇입니까?
DevOps 인터뷰 질문에 답하려면 기본적인 기본 사항을 이해하고 수정해야 합니다. 다음은 DevOps의 핵심 측면 또는 원칙입니다.

코드로서의 인프라
지속적인 통합
지속적인 배포
오토메이션
지속적인 모니터링
보안
4. DevOps 구현에 유용한 몇 가지 전제 조건을 설명하십시오.
DevOps 인터뷰 질문 은 지식을 테스트하는 방식으로 구성됩니다. 정확하고 정확한 답변을 하는 것이 중요합니다.

다음은 DevOps 구현에 유용한 몇 가지 중요한 전제 조건입니다.

조직의 고위급에서의 헌신
변화가 조직 전체에 전달되어야 함
버전 관리 소프트웨어
프로세스 준수를 위한 자동화 도구
자동화 테스트
자동화된 배포
5. 최고의 DevOps 도구는 무엇입니까? 어떤 도구를 작업했습니까?
이것은 자주 묻는 DevOps 인터뷰 질문 입니다. 정확한 답변을 원하시면 아래 답변을 참고해주세요.

DevOps 모델은 빠르고 안정적인 배포를 제공하기 위해 효과적인 도구에 의존합니다. 가장 인기 있는 DevOps 도구는 다음과 같습니다.

지라
GIT/SVN
비트버킷
젠킨스
대나무
소나큐브
아티팩토리/넥서스
도커
셰프/퍼펫/앤서블
IBM Urbancode Deploy/CA-RA
나기오스/스플렁크
이 목록에 더 많은 도구를 추가할 수 있지만 여기에 언급된 도구를 답변에 포함해야 합니다.

이 DevOps 인터뷰 질문의 두 번째 부분에는 두 가지 가능한 답변이 있습니다.

(i) 앞서 언급한 모든 도구에 대한 경험이 있는 경우 고품질 소프트웨어를 개발하고 소프트웨어를 쉽고 자주, 안정적으로 배포하기 위해 작업했다고 말할 수 있습니다.

(ii) 일부만 작업한 경험이 있는 경우 해당 도구를 언급하고 나머지 도구에 대한 개요를 제공합니다.

4. 이 모든 도구가 어떻게 함께 작동합니까?
이와 같은 DevOps 인터뷰 질문에 답하려면 먼저 명확한 답을 머릿속에 구상한 다음 응답하세요.

아래는 원활한 전달을 위해 모든 것이 자동화되는 일반적인 논리적 흐름입니다. 이 흐름은 조직마다 다를 수 있습니다.

스테이지 1

개발자는 코드를 만들고 소스 코드는 GIT와 같은 버전 제어 도구를 통해 관리됩니다.

2단계

GIT 저장소로 코드 전송.

3단계

Jenkins는 GIT 플러그인을 사용하여 저장소에서 코드를 가져오고 Ant 또는 Maven과 같은 도구를 사용하여 빌드합니다.

4단계

Puppet과 같은 구성 관리 도구 배포 및 테스트 환경 제공.

5단계

Jenkins는 테스트 환경에서 코드를 릴리스합니다. 테스트는 Selenium과 같은 도구를 사용하여 수행됩니다.

6단계

코드가 테스트되면 Jenkins는 Puppet과 같은 도구에 의해 프로비저닝 및 유지 관리되는 프로덕션 서버에 배포하기 위해 코드를 보냅니다.

7단계

배포 후 Nagios와 같은 도구로 지속적으로 모니터링합니다.

8단계

Docker 컨테이너는 빌드 기능을 테스트하기 위한 테스트 환경을 제공합니다.

![image](https://user-images.githubusercontent.com/62640332/149621384-2d528e2d-33be-4607-9c82-d93f6144f8c1.png)


7. 버전 관리 시스템이란 무엇입니까?
VCS(버전 제어 시스템)는 개발자가 함께 작업하고 작업의 전체 기록을 유지하는 데 도움이 되는 소프트웨어입니다.

VCS의 일부 기능은 다음과 같습니다.

개발자가 동시에 작업할 수 있습니다.
서로의 변경 사항을 덮어쓰는 것을 허용하지 않습니다.
모든 버전의 기록 유지
8. Selenium의 기술적 과제는 무엇입니까?
DevOps 인터뷰 질문 은 여러 도구에 대한 지식을 테스트합니다. 따라서 다양한 도구의 내부를 알아야 합니다.

다음은 Selenium의 몇 가지 기술적 과제입니다.

웹 기반 응용 프로그램만 지원합니다.
비트맵 비교를 지원하지 않습니다.
HP UFT와 같은 상용 도구에 비해 Selenium에 대한 공급업체 지원은 제공되지 않습니다.
개체 저장소 개념이 없기 때문에 개체의 유지 관리가 매우 복잡해집니다.

홈페이지 조항 마케팅 상위 21개 DevOps 인터뷰 질문 
상위 21개 DevOps 인터뷰 질문
게시 됨: 2021-07-24
DevOps 인터뷰 질문 은 까다로울 수 있으며 사전 준비가 필요합니다. 최근 가장 수익성이 높은 직업 중 하나인 DevOps는 지난 몇 년 동안 급증한 일자리와 함께 무수한 기회를 제공합니다.

수익 영향 기업인 MarketsandMarkets에 따르면 DevOps 산업은 예측 기간 동안 24.7%의 CAGR로 2017년 29억 달러에서 2023년 103억 1천만 달러로 성장할 것으로 예상됩니다.

고품질의 빠른 애플리케이션 제공에 대한 요구가 증가함에 따라 기업 간에 DevOps 솔루션 및 서비스에 대한 수요가 크게 증가할 것으로 예상됩니다. DevOps 엔지니어든 DevOps 입문을 생각하고 있든, 미래는 당신의 것입니다.

다음은 가장 자주 묻는 DevOps 인터뷰 질문과 놀라운 첫인상을 만들고 떠오르는 업계에 진출하기 위해 제공할 수 있는 가능한 응답입니다.

<br>
<br>




DevOps 인터뷰 질문 및 답변
목차

DevOps 인터뷰 질문 및 답변
1. DevOps와 Agile의 차이점은 무엇입니까?
2. DevOps가 필요한 이유는 무엇입니까?
3. DevOps의 핵심 측면 또는 원칙은 무엇입니까?
4. DevOps 구현에 유용한 몇 가지 전제 조건을 설명하십시오.
5. 최고의 DevOps 도구는 무엇입니까? 어떤 도구를 작업했습니까?
4. 이 모든 도구가 어떻게 함께 작동합니까?
7. 버전 관리 시스템이란 무엇입니까?
8. Selenium의 기술적 과제는 무엇입니까?
9. DevOps의 장점은 무엇입니까?
10. DevOps가 달성하는 데 도움이 되는 것은 무엇입니까?
11. DevOps를 산업/실생활에서 사용할 수 있는 사용 사례를 설명합니다.
12. DevOps의 안티 패턴은 무엇입니까?
13. 인프라 측면에서 구성 관리란 무엇입니까? 사용되는 몇 가지 인기 있는 도구를 언급하십시오.
14. DevOps에서 어떤 스크립팅 도구가 사용됩니까?
15. 세 가지 중요한 DevOps KPI의 이름을 지정하십시오.
16. 클라우드 기반 플랫폼의 DevOps 개발에 참여한 적이 있습니까? 그렇다면 어떤 클라우드 컴퓨팅 플랫폼입니까?
17. HTTP 요청의 유형은 무엇입니까?
18. GIT란 무엇입니까? GIT와 SVN의 차이점을 설명하세요.
19. GIT를 사용하면 어떤 이점이 있습니까?
20. 과거에 일한 조직의 소프트웨어 개발 측면과 기술 운영 측면 모두에 대한 이해와 전문성을 설명하십시오.
21. DevOps의 경력 관점에서 기대하는 것은 무엇입니까?
결론


1. DevOps가 필요한 이유는 무엇입니까?
이 DevOps 인터뷰 질문에 대한 응답은 일반적인 시장 동향에 대한 설명으로 시작해야 합니다. 기업은 작은 기능이 고객에게 빠르게 전달될 수 있는지 확인하려고 노력하고 있습니다. 고객의 빠른 피드백과 더 나은 소프트웨어 품질과 같은 여러 이점이 있어 고객 만족도가 높기 때문입니다.

이를 달성하기 위해 기업은 배포 빈도를 높이고 새 릴리스의 실패율을 낮추고 수정 간의 리드 타임을 단축하고 새 릴리스가 충돌하는 경우 평균 복구 시간을 단축해야 합니다.

DevOps는 이러한 모든 요구 사항을 충족하고 원활한 소프트웨어 제공을 제공합니다. Etsy, Google 및 Amazon은 몇 년 전만 해도 상상할 수 없었던 수준의 성능을 달성하기 위해 DevOps를 채택한 일부 회사의 예입니다.

이러한 수십억 달러 규모의 기업은 세계 최고 수준의 안정성, 안정성 및 보안을 제공하면서 매일 수천 개의 코드 배포를 실행합니다.

되는 길을 알고 싶습니다
데이터 과학 전문가 ?
상세한 브로셔를 다운로드 하고 업계 전문가와 함께하는 라이브 온라인 데모 클래스에 무료로 액세스하십시오.
날짜: 2021년 7월 24일(토요일) 시간: 오전 10:30 - 오전 11:30(IST/GMT +5:30)
이름 *
이메일 *
전화 *
나를 등록
 무료 오리엔테이션 세션에 등록하세요
코스 *
 강의 커리큘럼도 보내주세요
이용 약관 *
 Digital Vidya 개인정보 보호정책 및 이용약관에 동의합니다.
이름
이 필드는 유효성 검사용이며 변경되지 않은 상태로 두어야 합니다.

위의 버튼을 클릭하면 이용 약관 및 개인 정보 보호 정책에 동의하는 것입니다.

3. DevOps의 핵심 측면 또는 원칙은 무엇입니까?
DevOps 인터뷰 질문에 답하려면 기본적인 기본 사항을 이해하고 수정해야 합니다. 다음은 DevOps의 핵심 측면 또는 원칙입니다.

코드로서의 인프라
지속적인 통합
지속적인 배포
오토메이션
지속적인 모니터링
보안
4. DevOps 구현에 유용한 몇 가지 전제 조건을 설명하십시오.
DevOps 인터뷰 질문 은 지식을 테스트하는 방식으로 구성됩니다. 정확하고 정확한 답변을 하는 것이 중요합니다.

다음은 DevOps 구현에 유용한 몇 가지 중요한 전제 조건입니다.

조직의 고위급에서의 헌신
변화가 조직 전체에 전달되어야 함
버전 관리 소프트웨어
프로세스 준수를 위한 자동화 도구
자동화 테스트
자동화된 배포
5. 최고의 DevOps 도구는 무엇입니까? 어떤 도구를 작업했습니까?
이것은 자주 묻는 DevOps 인터뷰 질문 입니다. 정확한 답변을 원하시면 아래 답변을 참고해주세요.

DevOps 모델은 빠르고 안정적인 배포를 제공하기 위해 효과적인 도구에 의존합니다. 가장 인기 있는 DevOps 도구는 다음과 같습니다.

지라
GIT/SVN
비트버킷
젠킨스
대나무
소나큐브
아티팩토리/넥서스
도커
셰프/퍼펫/앤서블
IBM Urbancode Deploy/CA-RA
나기오스/스플렁크
이 목록에 더 많은 도구를 추가할 수 있지만 여기에 언급된 도구를 답변에 포함해야 합니다.

이 DevOps 인터뷰 질문의 두 번째 부분에는 두 가지 가능한 답변이 있습니다.

(i) 앞서 언급한 모든 도구에 대한 경험이 있는 경우 고품질 소프트웨어를 개발하고 소프트웨어를 쉽고 자주, 안정적으로 배포하기 위해 작업했다고 말할 수 있습니다.

(ii) 일부만 작업한 경험이 있는 경우 해당 도구를 언급하고 나머지 도구에 대한 개요를 제공합니다.

4. 이 모든 도구가 어떻게 함께 작동합니까?
이와 같은 DevOps 인터뷰 질문에 답하려면 먼저 명확한 답을 머릿속에 구상한 다음 응답하세요.

아래는 원활한 전달을 위해 모든 것이 자동화되는 일반적인 논리적 흐름입니다. 이 흐름은 조직마다 다를 수 있습니다.

스테이지 1

개발자는 코드를 만들고 소스 코드는 GIT와 같은 버전 제어 도구를 통해 관리됩니다.

2단계

GIT 저장소로 코드 전송.

3단계

Jenkins는 GIT 플러그인을 사용하여 저장소에서 코드를 가져오고 Ant 또는 Maven과 같은 도구를 사용하여 빌드합니다.

4단계

Puppet과 같은 구성 관리 도구 배포 및 테스트 환경 제공.

5단계

Jenkins는 테스트 환경에서 코드를 릴리스합니다. 테스트는 Selenium과 같은 도구를 사용하여 수행됩니다.

6단계

코드가 테스트되면 Jenkins는 Puppet과 같은 도구에 의해 프로비저닝 및 유지 관리되는 프로덕션 서버에 배포하기 위해 코드를 보냅니다.

7단계

배포 후 Nagios와 같은 도구로 지속적으로 모니터링합니다.

8단계

Docker 컨테이너는 빌드 기능을 테스트하기 위한 테스트 환경을 제공합니다.

DevOps Interview Questions
출처 – 매체

7. 버전 관리 시스템이란 무엇입니까?
VCS(버전 제어 시스템)는 개발자가 함께 작업하고 작업의 전체 기록을 유지하는 데 도움이 되는 소프트웨어입니다.

VCS의 일부 기능은 다음과 같습니다.

개발자가 동시에 작업할 수 있습니다.
서로의 변경 사항을 덮어쓰는 것을 허용하지 않습니다.
모든 버전의 기록 유지
8. Selenium의 기술적 과제는 무엇입니까?
DevOps 인터뷰 질문 은 여러 도구에 대한 지식을 테스트합니다. 따라서 다양한 도구의 내부를 알아야 합니다.

다음은 Selenium의 몇 가지 기술적 과제입니다.

웹 기반 응용 프로그램만 지원합니다.
비트맵 비교를 지원하지 않습니다.
HP UFT와 같은 상용 도구에 비해 Selenium에 대한 공급업체 지원은 제공되지 않습니다.
개체 저장소 개념이 없기 때문에 개체의 유지 관리가 매우 복잡해집니다.
DevOps Interview Questions
출처 – 업네틱스

9. DevOps의 장점은 무엇입니까?
이 DevOps 인터뷰 질문에 답하기 위해 귀하의 경험을 사용할 수 있습니다. 경험이 없는 경우 다음과 같은 장점을 언급할 수 있습니다.

기술적 이점 –

지속적인 소프트웨어 제공
해결해야 할 복잡한 문제 감소
더 빠른 문제 해결
비즈니스 혜택 –

더 빠른 기능 제공
안정적인 운영 환경
가치를 추가하는 데 더 많은 시간(유지보수보다)
10. DevOps가 달성하는 데 도움이 되는 것은 무엇입니까?
DevOps의 기본 사항에 대해 간략하게 설명하고 긍정적인 측면을 자세히 설명하여 이 DevOps 인터뷰 질문 에 답 하세요 .

DevOps는 소프트웨어 품질 보증 및 규정 준수의 위험을 최소화하면서 최대한 신속하고 원활하게 프로덕션 변경을 달성하는 데 도움이 됩니다. DevOps의 다른 긍정적인 효과로는 팀 간의 더 명확한 의사 소통과 더 나은 작업 관계가 있습니다. 운영 팀과 개발 팀은 모두 협력하여 양질의 소프트웨어를 제공하여 고객 만족도를 높입니다.

11. DevOps를 산업/실생활에서 사용할 수 있는 사용 사례를 설명합니다.
많은 회사에서 DevOps를 사용합니다. 이 DevOps 인터뷰 질문에 답하려면 익숙한 사례를 언급하거나 아래에 제공된 예를 참조하세요.

Etsy는 독립 창작자를 지원하는 핸드메이드 또는 빈티지 아이템 및 공예 용품에 중점을 둔 전자 상거래 웹사이트입니다. 이 때문에 자주 충돌의 원인이 느린 웹 사이트 업데이트에 여러 가지 문제에 직면했다. 이는 온라인 판매 및 마케팅 플랫폼에서 상품을 판매한 수백만 명의 사용자에게 부정적인 영향을 미쳤습니다.

매주 두 번 4시간 전체 사이트 배포를 생성하는 폭포식 모델에서 새로운 기술 관리 팀의 도움을 받아 보다 민첩한 접근 방식으로 전환했습니다. 오늘날에는 완전히 자동화된 배포 파이프라인이 있습니다. 지속적 전달 방식으로 인해 최소한의 중단으로 하루에 50개 이상의 배포 가 이루어졌다고 합니다.

12. DevOps의 안티 패턴은 무엇입니까?
다른 사람들이 채택한 패턴이 조직에 적합하지 않고 계속 맹목적으로 따르는 경우 본질적으로 안티 패턴을 채택하고 있는 것입니다. 이 DevOps 인터뷰 질문에 답하는 데 도움이 되도록 아래에 몇 가지 안티 패턴 목록이 제공됩니다.

DevOps는 프로세스입니다.
DevOps는 단지 개발 팀과 운영 팀을 병합하는 것입니다.
애자일과 DevOps는 동일합니다.
DevOps는 도구에 관한 모든 것입니다.
DevOps는 자동화에 관한 것입니다.
DevOps와 보안은 적입니다.
DevOps는 레거시 시스템에서 실현 가능하지 않습니다.
13. 인프라 측면에서 구성 관리란 무엇입니까? 사용되는 몇 가지 인기 있는 도구를 언급하십시오.
구성 관리는 제공 및 인프라 운영을 자동화하는 데 관련된 다양한 도구와 사례로 구성됩니다. 여기에는 애플리케이션이 개발되면 애플리케이션 배포를 위해 서버를 준비 상태로 유지하는 것이 포함됩니다. 이 DevOps 인터뷰 질문 의 두 번째 부분에 답하려면 이 공간에서 Chef, Puppet 및 Ansible과 같은 구성 관리 작업을 자동화하는 데 사용되는 몇 가지 인기 있는 도구를 언급하십시오.

14. DevOps에서 어떤 스크립팅 도구가 사용됩니까?
Python과 Ruby는 DevOps에서 사용되는 스크립팅 도구입니다.

15. 세 가지 중요한 DevOps KPI의 이름을 지정하십시오.
이 DevOps 인터뷰 질문에 답하는 데 도움이 되도록 아래에 세 가지 일반적인 DevOps KPI가 언급되어 있습니다.

그 동안 장애 복구
배포 빈도
실패한 배포 비율
16. 클라우드 기반 플랫폼의 DevOps 개발에 참여한 적이 있습니까? 그렇다면 어떤 클라우드 컴퓨팅 플랫폼입니까?
클라우드 기반 플랫폼의 DevOps 개발에 참여했는지 여부에 따라 이 DevOps 인터뷰 질문에 답할 수 있습니다. 있는 경우 인기 있는 클라우드 컴퓨팅 플랫폼의 다음 예를 제공하십시오.

AWS – 아마존 웹 서비스
마이크로소프트 애저
구글 클라우드
17. HTTP 요청의 유형은 무엇입니까?
다음은 HTTP 요청 유형입니다.

가져 오기
머리
경타
우편
반점
삭제
추적하다
연결하다
옵션
18. GIT란 무엇입니까? GIT와 SVN의 차이점을 설명하세요.
GIT는 크고 작은 프로젝트를 효율적으로 처리하는 SCM(소스 코드 관리) 도구입니다. GitHub와 같은 원격 서버에 리포지토리를 저장하는 데 사용됩니다.

힘내

SVN

GIT는 분산 버전 관리 도구입니다.

SVN은 중앙 집중식 버전 관리 도구입니다.

밀기 및 당기기 작업이 빠릅니다.

밀기 및 당기기 작업은 상대적으로 느립니다.

3세대 버전 관리 도구에 속합니다.

2세대 버전 관리 도구에 속합니다.

커밋은 온라인뿐만 아니라 오프라인에서도 수행할 수 있습니다.

커밋은 온라인에서만 수행할 수 있습니다.

19. GIT를 사용하면 어떤 이점이 있습니까?
GIT 사용의 몇 가지 이점은 다음과 같습니다.

저장소당 하나의 GIT 디렉토리
우수한 디스크 활용도 및 네트워크 성능
협업 친화적
다양한 종류의 프로젝트에 사용할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149621400-ca150def-1161-4932-b414-53abb346d968.png)


20. 과거에 일한 조직의 소프트웨어 개발 측면과 기술 운영 측면 모두에 대한 이해와 전문성을 설명 하십시오.
이 DevOps 인터뷰 질문에는 이전 직장에서 얻은 소중한 경험을 활용해야 합니다. DevOps 엔지니어로서의 역할과 24-7 환경에서 어떻게 작업했는지에 대한 정보를 제공하십시오. 따라서 지속적인 소프트웨어 배포를 지원하기 위해 프로세스를 성공적으로 자동화하는 전문 지식을 얻습니다. 또한 퍼블릭/프라이빗 클라우드, Chef 또는 Puppet과 같은 도구, Python 및 PHP와 같은 도구를 사용한 스크립팅 및 자동화, Agile에 대한 높은 수준의 숙련도에 대한 경험에 대해 논의하십시오.

21. DevOps의 경력 관점에서 기대하는 것은 무엇입니까?
이 특정 DevOps 인터뷰 질문에 대한 귀하의 응답 은 엔드 투 엔드 전달 프로세스에 참여하려는 열정과 프로세스를 개선하려는 의지를 보여주어야 합니다 . 개발 및 운영 팀이 함께 일하고 서로의 관점을 이해하기를 바라는 것과 같은 측면을 포함하면 귀하가 팀 플레이어임을 증명하고 직업 선택의 기회를 향상시킬 수 있습니다.


결론
DevOps 엔지니어는 데이터 분석 도구, 프로세스 및 관련 기술에 대한 심층적인 지식이 필요합니다. 애자일 프로세스와 이 기사에서 언급한 모든 도구에 능숙해야 합니다. 또한 제품, 서비스 및 시스템에 대한 전체적인 이해가 있어야 합니다.

이 튜토리얼의 DevOps 질문은 DevOps 인터뷰에 자신 있게 응시하고 이 분야에서 훌륭한 경력을 쌓을 수 있도록 도와줄 것입니다. 귀하의 답변이 여기에 제공된 답변과 거의 일치한다면 DevOps 전문가로서 인터뷰에 응할 준비가 된 것입니다.

또한 Digital Vidya의 Python 프로그래밍 과정 을 통해 이제 DevOps에서 사용되는 가장 인기 있는 스크립팅 도구 중 하나의 전문가가 될 수 있습니다.

우리는 당신에게 성공과 행운을 빕니다


---

Part 1. 직무

이 직무가 가진 장·단점은 어떤 게 있을까요?
가장 큰 장점은 새로운 기술을 다양하게 학습할 수 있고, 활용할 수 있다는 점입니다. 또, 자동화 작업을 통해서 과거에는 시간이 많이 소요되었던 작업들을 빠르고 효율적으로 단축하게 할 수 있다는 것에 보람을 느낍니다. 효율적인 것을 추구하는 분들에게는 이런 자동화 작업들에 큰 재미와 보람을 느끼실 수 있습니다.

 

반면에 단점은 끊임없는 학습과 많은 시간이 투여된다는 점입니다. 기존에 수작업으로 했던 과정들을 자동화하려면 그에 대한 다양한 지식이 필요하며 기술변화의 흐름도 빠르기에 이런 것에 익숙하지 않은 분이라면 업무가 힘들게 느껴질 수 있습니다.



Part 2. 역량

이 일을 하기 위해 필요한 역량과 자질은 무엇일까요?
기본적으로 Python이든 어떤 언어든 기본적인 프로그래밍 능력과 개발 능력이 필요합니다. 특정 언어에 한정된 것은 아니지만, 클라우드 기반의 프로그래밍 능력이 있어야 하므로 클라우드에 대한 이해 역시 필수입니다. 클라우드 인프라를 만들고 구성하는 데 가장 많이 사용되고 있는 프로그램으로는 Terra form 이 있으며, Ansible, Salt stack 같은 설정관리 프로그램도 많이 사용하고 있기 때문에 해당 Tool들을 사용해보신 경험이 있다면 좋겠습니다.

 

또한, 호기심 있는 성격은 플러스 요인입니다. 항상 탐구하고 학습해야 하는 업무가 많고, 클라우드 관련 기술뿐만 아니라 전반적인 기술의 변화가 굉장히 빠르기 때문에 끊임없이 학습하고 배우고자 하는 태도를 지니신 분이 업무에 잘 적응할 수 있습니다.

개인의 역량을 업그레이드 하기 위해 특별히 노력하고 계신 게 있다면 소개해주세요.
저는 AWS, Linux 와 같은 기술 트렌드 관련된 뉴스레터를 챙겨봅니다. SNS를 통해서도 GCP, Container 등과 같은 기술 트렌드를 접하고 있으며 이런 내용들은 직접적으로 실무에 도움이 된다기보다는 전반적인 흐름을 읽는 데 도움이 됩니다. 과거에는 각광받던 프로그램일지라도 기술의 변화함에 따라 자주 쓰이지 않을 수 있고, 또 최근에는 자주 쓰이지 않는 프로그램일지라도 추후에 필요해질 수 있습니다. 그렇기 때문에 필요한 기술과 필요하지 않은 기술을 구분 짓지 않고 다양한 기술을 미리미리 익히고 있어야 필요할 때 빠르게 도입하고 활용할 수 있습니다. 그런 측면에서 기술 트렌드 관련 정보를 접하는 것은 중요하다고 생각합니다.

<br>

---

<br>

DevOps란?
DevOps란 애플리케이션과 서비스를 빠른 속도로 제공할 수 있는 있도록 조직의 역량을 향상시키는 문화 철학, 방식 및 도구의 조합이다. 기존의 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있다. 이러한 빠른 속도를 통해 조직은 고객을 더 잘 지원하고 시장에서 좀 더 효과적으로 경쟁할 수 있다.

DevOps에는 어떤 방식이 있는가?
DevOps의 모범 사례는 다음과 같다.

- 지속적 통합 (CI)    
- 지속적 전달 (CD)    
- 마이크로 서비스 (MSA)    
- 코드형 인프라 (Infrastructure as Code)    
- 모니터링 및 로깅    
- 커뮤니케이션 및 협업 
     
- CI란 무엇인가?   
   
CI는 Continuous Integration의 줄임말로, 지속적인 통합을 의미한다.
CI를 성공적으로 구현할 경우, 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 repository에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있다.




![image](https://user-images.githubusercontent.com/62640332/149621644-a7167a3a-cdc8-4cf7-a0e9-b1cb89c0f3ee.png)

CD란 무엇인가?
CD는 지속적인 서비스 제공 (Continuous Delivery) 또는 지속적인 배포(Continuous Deployment)를 의미하며 두 용어는 상호 교환적으로 사용된다.

- 지속적인 제공이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 repository에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 repository에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있다. 이는 개발팀과 비즈니스팀 간의 가시성과 커뮤니케이션 부족 문제를 해결해 준다. 또한 지속적인 제공은 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 한다.

- 지속적인 배포란 개발자의 변경 사항을 repository에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 release하는 것을 의미한다. 이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 과부하 문제를 해결한다.

![image](https://user-images.githubusercontent.com/62640332/149621673-2d558093-5fc4-4e8b-ad35-d4a8c593cee0.png)


Jenkins vs. Travis CI vs. Circle CI
Jenkins

Jenkins는 자바 기반의 프로그램이다. 젠킨스는 플러그인 아키텍처를 통해 확장이 가능해서 거의 불가능 한 부분이 없을 정도로 많은 가능성을 제공한다. Jenkins는 dedicated server를 요구하기 때문에 추가적인 금액이 발생할 수 있고, configuration / customization 하는데 시간이 필요한 것이 단점이다.
젠킨스는 플러그인을 통해 많은 커스터마이징이 가능하므로 큰 프로젝트에 많이 사용된다. 즉, 빠르게 CI 시스템을 사용해야 한다면 젠킨스는 좋은 선택이 아닐 수 있다.

- Travis CI

Travis CI는 클라우드 기반의 서버이며, YAML file로 구성하고, 테스트를 실행하도록 docker를 지원한다.
CI 시스템중에 가장 많은 언어를 지원한다. Travis CI는 빠르고, YAML config를 사용해 가볍고, 무료이지만 Circle CI와 비교했을 때, 기업 플랜이 더 비싸고 커스터마이징이 제한되어 있다.
Travis CI는 여러 환경에서 테스트되야 하는 오픈 소스 프로젝트에 적합하다.

- Circle CI

Circle CI 역시 클라우드 기반의 시스템이며 Travis CI와 매우 흡사하다. 즉, Circle CI는 YAML config로 가볍고, 빠르게 시작할 수 있다. Circle CI를 사용하면 dedicated sever(단독으로 제공된 서버 위에서 하나의 서비스를 제공하는 서비스)가 필요 없으며, 관리할 필요가 없어진다 (Travis CI 동일).
Circle CI는 최대한 빨리 통합해야하는 목적을 가진 작은 프로젝트에 적합하다.

그 외, Gitlab CI, TeamCity같은 툴도 있다.

- Microservices Architecture란?
  
마이크로서비스는 애플리케이션 구축을 위한 아키텍처 기반의 접근 방식이다.
마이크로서비스를 전통적인 monolithic 접근 방식과 구별 짓는 기준은, 애플리케이션을 핵심 기능으로 세분화하는 방식을 사용하는가이다. 마이크로서비스에서는 각 기능을 서비스라고 부르고, 독립적으로 구축하고 배포할 수 있다. 이렇게 함으로 개별 서비스가 다른 서비스에 부정적 영향을 주지 않으면서 작동(또는 장애가 발생)할 수 있다.

쉽게 비유하면, 어떤 쇼핑몰에 접속했을 때 보이는 검색창, 추천 내역, 장바구니, 이 모든 것이 하나의 서비스이다.
즉, 마이크로서비스란 애플리케이션의 핵심 기능이면서 다른 서비스들과 독립적으로 작동한다.
애플리케이션 핵심 기능을 유연하게 결합할 뿐 아니라, 불가피한 장애, 향후 확장 여부 및 새로운 기능 통합에 대비할 수 있도록 서비스 간 커뮤니케이션 및 개발팀의 구조를 조정하는 practice이다.

![image](https://user-images.githubusercontent.com/62640332/149621709-22de290c-65cf-49d7-9ce1-217d86f8d3ef.png)


코드형 인프라란 무엇인가?
'프로그래밍형 인프라'라고도 불리는 코드형 인프라 (Infrastructure as Code)는 인프라 구성을 마치 소프트웨어를 프로그래밍하는 것처럼 처리하는 방식을 가리킨다.

코드형 인프라는 어떤 장점을 가지고 있는가?
- 빠른 속도와 편리함    
- 수동 구성이 아닌 자동화로 일관성 있는 구성    
- 실제 인프라에 적용하기 전 테스트 실행으로 위험 최소화    
- 구성하고 싶은 인프라를 코드를 제출 - 업무효율 극대화    
- 반복적인 작업을 자동화하고 인프라 구성 프로세스를 최적화 함으로 생산성 증가    

<br>

---

<br>

Kubernetes
VM vs container
:두 개 모두 가상화 기술로 큰 차이는 HyperVisor 유무이다. VM의 경우 운영체제에서 프로세스가 시작하는 반면 컨테이너는 호스트 운영체제의 내부에서 실행되어 좀 더 가볍고 MSA 구현이 가능하다. 또한, 운영체제 커널의 공유함으로써 빠르며 메모리 사용량이 적다.

![image](https://user-images.githubusercontent.com/62640332/149621746-846ec536-0ca1-41aa-bf8d-b12271e40cf4.png)


질문 1
구성을 코드로 어떻게 정의 하고 어떤 보안 이점을 제공합니까? 코드로서의 구성과 관련하여 재수 화의 중요성을 설명하십시오.

대답
ㅏ. 코드로 구성은 소스 저장소에서 구성 리소스를 관리하는 것으로 설명 할 수 있습니다. 애플리케이션 구성 리소스는 버전이 지정된 아티팩트로 처리됩니다.

애플리케이션 코드와 함께 애플리케이션 환경을 관리하면 코드와 동일한 이점을 얻을 수 있습니다.

비. Rehydration은 자동화 된 방식으로 코드에서 클라우드 환경과 리소스를 완전히 다시 생성 할 수있는 기능을 제공합니다.

재수 화의 개념을 활용하면 이러한 유형의 환경에있는 데이터를 최신 인프라 패치, 구성 설정 및 기타 관련 보안 정책 설정을 포함하는 새롭고 업데이트 된 인스턴스로 복원 할 수 있습니다.

질문 2
IaaS (Infrastructure as a Service), PaaS (Platform as a Service), Platform as a Service 및 Software as a Service (SaaS) 간의 클라우드 컴퓨팅 보안 아키텍처 모델의 차이점을 설명합니다.

대답
IaaS : 주로 주문형 데이터 센터 인프라 제공에 중점을 둡니다. 클라우드 기반 서비스, 스토리지, 네트워킹 및 가상화와 같은 종량제 서비스. 기업이 클라우드를 관리하고 상호 작용할 수 있도록 API (애플리케이션 프로그래밍 인터페이스)에 크게 의존합니다.

PaaS : 기본 하드웨어 및 소프트웨어를 구매 및 관리하고 호스팅 기능을 프로비저닝하는 데 드는 비용과 복잡성없이 애플리케이션을 배포 할 수 있습니다.

PaaS 공급 업체는 인터넷을 통해 하드웨어 및 소프트웨어 도구를 제공하며 사람들은 이러한 도구를 사용하여 애플리케이션을 개발합니다. PaaS 사용자는 개발자 인 경향이 있습니다.


 
SaaS : 이러한 플랫폼은 일반적으로 월 구독료로 인터넷을 통해 사용자가 소프트웨어를 사용할 수 있도록합니다. 사용자는 일반적으로 모든 장치에서 언제든지 (인터넷에 연결되어있는 한) 소프트웨어에 액세스 할 수 있습니다.

질문 3
DevOps의 필요성은 무엇입니까?

대답
제 말에 따르면이 대답은 일반적인 시장 동향을 설명하는 것부터 시작해야합니다.

많은 기능을 출시하는 대신 기업은 일련의 출시 과정을 통해 작은 기능을 고객에게 전달할 수 있는지 확인하려고합니다.

이것은 고객의 빠른 피드백, 소프트웨어의 품질 향상 등과 같은 많은 이점을 가지고 있으며 결과적으로 높은 고객 만족도로 이어집니다.

이를 달성하기 위해 기업은 다음을 수행해야합니다.

배포 빈도를 높입니다.
새 릴리스의 실패율을 낮 춥니 다.
수정 사이의 리드 타임을 단축합니다.
새 릴리스가 충돌하는 경우보다 빠른 평균 복구 시간.
Etsy, Google, Amazon과 같이 DevOps를 채택 하여 5 년 전에도 상상할 수 없었던 수준의 성능을 달성 한 회사의 예를들 수 있습니다 .

세계 최고 수준의 안정성, 안정성 및 보안을 제공하면서 하루에 수십, 수백 또는 수천 번의 코드 배포를 수행하고 있습니다.

질문 4
최고의 DevOps 도구는 무엇입니까? 작업 한 도구는 무엇입니까?

대답
가장 널리 사용되는 DevOps 도구는 다음과 같습니다.

- Git : 버전 관리 시스템 도구
- Jenkins : 지속적 통합 도구
- Selenium : 연속 테스트 도구
- Puppet , Chef , Ansible : 구성 관리 및 배포 도구
- Nagios : 지속적인 모니터링 도구
- Docker : 컨테이너화 도구
답변의 두 번째 부분에는 두 가지 가능성이 있습니다.

위의 모든 도구에 대한 경험이 있다면 좋은 품질의 소프트웨어를 개발하기 위해 이러한 모든 도구를 사용했으며 이러한 유형의 소프트웨어를 쉽고 자주, 안정적으로 배포했다고 말할 수 있습니다.
위의 도구 중 일부만 사용해 본 경험이있는 경우 해당 도구를 언급하고 이러한 도구에 대한 전문성을 갖추고 있으며 나머지 도구에 대한 개요를 가지고 있다고 말하십시오.
이 모든 도구는 어떻게 함께 작동합니까?

대답
다음은 원활한 전달을 위해 모든 것이 자동화되는 일반적인 논리적 흐름입니다. 그러나이 흐름은 요구 사항에 따라 조직마다 다를 수 있습니다.

개발자가 코드를 개발하고이 소스 코드는 Git 등과 같은 버전 제어 시스템 도구로 관리됩니다.
개발자는이 코드를 Git 리포지토리로 보내고 코드의 모든 변경 사항은이 리포지토리에 커밋됩니다.
Jenkins는 Git 플러그인을 사용하여 저장소에서이 코드를 가져오고 Ant 또는 Maven 과 같은 도구를 사용하여 빌드합니다 .
Puppet과 같은 구성 관리 도구는 테스트 환경을 배포하고 프로비저닝 한 다음 Jenkins는 Selenium과 같은 도구를 사용하여 테스트가 수행되는 테스트 환경에서이 코드를 릴리스합니다.
코드가 테스트되면 Jenkins는 프로덕션 서버에 배포하기 위해 코드를 보냅니다 (프로덕션 서버도 Puppet과 같은 도구에 의해 프로비저닝되고 유지 관리 됨).
배포 후 Nagios와 같은 도구를 통해 지속적으로 모니터링됩니다.
Docker 컨테이너는 빌드 기능을 테스트하기위한 테스트 환경을 제공합니다.

출처 : https://www.cloudbees.com/blog/orchestrating-devsecops-security-speed
DevOps의 안티 패턴은 무엇입니까?

대답
패턴은 일반적으로 따르는 일반적인 사용법입니다. 다른 사람들이 일반적으로 채택한 패턴이 조직에 적합하지 않고 계속 맹목적으로 따르는 경우 본질적으로 안티 패턴을 채택하는 것입니다.

DevOps에 대한 신화가 있습니다. 그중 일부는 다음과 같습니다.

- DevOps는 프로세스입니다.
- Agile은 DevOps와 동일합니다.
- 별도의 DevOps 그룹이 필요합니다.
- DevOps는 우리의 모든 문제를 해결할 것입니다.
- DevOps는 프로덕션을 관리하는 개발자를 의미합니다.
- DevOps는 개발 기반 릴리스 관리입니다.
- DevOps는 개발 중심이 아닙니다.
- DevOps는 IT 운영 중심이 아닙니다.
- 우리는 DevOps를 할 수없고 독특합니다.
- 우리는 DevOps를 할 수 없으며 잘못된 사람들이 있습니다.
- 브라우저에 URL을 입력하고 이동을 누르면 어떻게되는지 설명하십시오.

대답
브라우저에 URL을 입력하고 Enter 키를 누르면 어떻게됩니까?
질문 8
DevOps를 채택하기위한 비즈니스 요구 또는 비즈니스 동인은 무엇입니까?

대답
DevOps의 비즈니스 가치
결론
분명히 이것은 잠재적 인 DevOps 인터뷰 질문의 샘플 일뿐입니다. 잠재적 인 질문 목록은 엄청날 것입니다. 인터뷰 과정에서 가장 좋아하는 질문은 무엇입니까?

---


- 좋은 데브옵스 소프트웨어 엔지니어는 어떤 사람일까요?
 

침착하고 객관적으로 문제의 원인을 핀포인팅 할 줄 아는 사람을 찾고 있습니다. 아무래도 장애 상황을 맞을 일이 있기 때문에 이에 대응하기 위해선 문제의 원인을 정확하게 파악할 필요가 있다고 생각합니다. 또 개발팀 간의 사일로를 허물어야 하므로 사내의 다양한 구성원들과 원활하게 커뮤니케이션이 가능한 사람이 좋습니다. 무엇보다 반복적일 수 있는 인프라 관리 작업을 최대한 자동화하는 데 매력을 느끼는 사람입니다. 현재 인프라도 이전과 다르게 프로그램을 통해서 관리가 가능합니다. 이는 즉 자동화가 가능하다는 것입니다. 자동화를 통해서 휴먼 에러를 줄이고 인프라에 빠르고 안정적으로 작업을 하려고 하기 때문입니다. 더욱 효율적으로 일 하는 개발문화에 기여하고 싶은 사람이라면 꼭 지원했으면 좋겠습니다. 행복한 개발자가 좋은 프로덕트를 만든다고 생각합니다.

<br>

---

<br>

- cs 지식

질문 받은 내용
객체의 life cycle
파이썬 실행했을 때 메모리와 cpu에서 일어나는 일을 질문 받았지만, 우선 class를 기준으로 설명해놓은 블로그를 찾아서 해당 내용으로 정리한다. (참고 링크)

The life cycle of an object consists of three basic steps:

- creation: 클래스를 정의하고 인스턴스를 생성한다. 이 때 객체에 메모리가 할당되고, 객체가 조작될 준비를 마치게 된다. __init__
handling

- destruction: 객체의 reference count가 0이 될 때, 더이상 참조하는 값이 없을 때 객체가 삭제된다. 객체가 필요 없어졌을 때 제거하는 것을 garbage collection이라고 한다. __del__

[thread와 multiprocess의 차이]

python은 thread보다 process를 통한 병렬처리를 더 선호한다고 한다. GIL 때문에 multiprocess로 작업하는 것이 더 빠르다.

multiprocessing을 thread 대신 사용해 multi core CPU의 장점을 사용할 수 있고, global interpreter lock 병목 현상을 피할 수 있다.


[parameter와 argument의 차이]

- parameter: 함수를 정의할 때 사용
- argument: 함수를 호출할 때 사용
- Call by value, call by reference
- Call by value(값에 의한 호출)는 인자로 받은 값을 복사하여 처리를 한다. Call by reference(참조에 의한 호출)는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다. 간단히 말해 값을 복사를 하여 처리를 하느냐, 아니면 직접 참조를 하느냐 차이인 것이다. (참고 링크)

ㅁ Call by value(값에 의한 호출)

- 장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.
- 단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.

ㅁ Call by reference(참조에 의한 호출)

- 장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
- 단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)

Python 은 명시적인 Call by Reference 혹은 Call by Value 라는 개념이 존재하지 않는다.

Python의 function에 argument 를 전달할 때, 이는 Manual 에 따르면 call by assignment 라는 방식으로 전달된다. 이는 Parameter로 전달받는 객체에 따라 객체의 참조방식이 결정된다는 의미로, 공식 문서에 따르면 Mutable Object 는 Call by reference의 형태로 참조형으로 변수를 다루며 Immutable Object는 Call by value 의 형태로 변수를 핸들링한다.

- Mutable Object : list, dict, set 등의 객체

- Immutable Object : str, int, tuple 등의 객체

출처: https://jins-dev.tistory.com/entry/Python-의-Call-by-assignment-의-개념 [Jins' Dev Inside]

![image](https://user-images.githubusercontent.com/62640332/149622088-4d55e22a-55af-489a-815e-e5418cf2bd44.png)

iterable object
리스트, Set, Dictionary와 같은 컬렉션이나 문자열과 같은 문자 Sequence 등은 for 문을 써서 하나씩 데이타를 처리할 수 있는데, 이렇게 하나 하나 처리할 수 있는 컬렉션이나 Sequence 들을 Iterable 객체(Iterable Object)라 부른다.

iterator
이터레이터는 값 생성기이다. “다음"값을 요청할 때마다 내부 상태를 유지하고 있기 때문에 다음값을 계산하는 방법을 알고있다.

generator
Generator 함수(Generator function)는 함수 안에 yield 를 사용하여 데이타를 하나씩 리턴하는 함수이다. Generator 함수가 처음 호출되면, 그 함수 실행 중 처음으로 만나는 yield 에서 값을 리턴한다. Generator 함수가 다시 호출되면, 직전에 실행되었던 yield 문 다음부터 다음 yield 문을 만날 때까지 문장들을 실행하게 된다. (참고 링크)

너무 정리가 잘 되어있는 글: [번역] 이터레이터와 제너레이터

GIL(Global interpreter lock)
너무 잘 정리되어 있는 블로그 참고

전역 인터프리터 잠금은 컴퓨터 언어 인터프리터에서 스레드 실행을 동기화하여 한 번에 하나의 기본 스레드 만 실행할 수 있도록하는 메커니즘입니다. GIL을 사용하는 인터프리터는 멀티 코어 프로세서에서 실행 되더라도 항상 한 번에 하나의 스레드 만 실행할 수 있습니다.

파이썬에서 쓰레드을 여러 개 생성한다고 해서 여러 개의 쓰레드가 동시에 실행되는 것은 아니다. 정확히 말하자면 두 개의 쓰레드가 동시해 실행되는 것처럼 보일 뿐, 특정 시점에서는 여러 개의 쓰레드 중 하나의 쓰레드만 실행된다.

파이썬은 멀티 쓰레딩 환경에서 각 쓰레드가 특정 객체를 사용할 경우 처리가 어려워(복잡한 이유지만 변수 관리 방법과 연관이 있음), 이러한 걱정을 할 필요가 없도록 특정 시점에서 하나의 쓰레드만 실행되도록 락을 걸어 두었다.

Global Interpreter Lock 이라는 이름이 지칭하듯이, 파이썬 인터프리터 (Interpreter) 자체에서 락을 (Lock) 전역적으로 (Global) 설정해 둔 것이다. 이로 인해 여러 쓰레드가 동시에 사용하는 공유 자원 동기화 문제는 자연스럽게 해결된다. C Extension으로 래핑된 라이브러리를 사용할 때도 Thread Safety를 고려할 필요가 없다고도 한다.

sync & async
링크에 라이브러리(async.io)를 사용해 비동기처리 방식을 간단하게 정리해놓았다. 동기는 시간을 맞추는 것이다. A 함수를 호출하는데 걸리는 시간이 1초, B가 2초라 할 때 총 3초가 걸린다.

반면 비동기는 시간을 맞추지 않는 것으로, 동시에 호출되기 때문에 총 2초가 걸리게 된다.

Blocking
Blocking은 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 것이다. 예를 들어 호출하는 함수가 IO를 요청했을 때 IO처리가 완료될 때까지 아무 일도 하지 못한 채 기다리는 것을 말한다.

Non-Blocking
Non-Blocking은 Blocking과 반대되는 개념이다. 직접 제어할 수 없는 대상의 작업 처리 여부와 상관이 없다. 예를 들어 호출하는 함수가 IO를 요청한 후 IO처리 완료 여부와 상관없이 바로 자신의 작업을 할 수 있다.

내가 추가
메모리
주기억장치(主記憶裝置) 또는 컴퓨터 메모리(computer memory)는 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치를 가리킨다. 이 용어는 1차 기억 장치와 동의어이다.

메모리는 RAM(Random Access Memory) 또는 ROM(Read Only Memory)처럼 일시적으로 기억을 저장할 수 있는 모든 물리 장치를 말한다.

CPU
데코레이터
데코레이터 사용해봤는지
중첩해서 사용한다면 순서는 어떻게 되는지

유닛테스트


---

<h1> 1. 프로그래밍 공통 </h1>

[ OOP란 ]
OOP는 현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물들을 객체로 보고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법입니다. OOP로 코드를 작성하면 재사용성과 변형가능성을 높일 수 있습니다.

 

 

[ OOP의 5가지 설계 원칙 ]

- SRP(Single Responsibility Principle, 단일 책임 원칙): 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
- OCP(Open-Closed Principle, 개방 폐쇠 원칙): 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.
- DIP(Dependency Inversion Principle, 의존 역전 법칙): 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안된다.
 

 

[ 절차지향 프로그래밍 VS 객체지향 프로그래밍 ]
 

ㅁ 절차지향 프로그래밍

- 물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다.
- 가장 대표적인 언어로 C언어가 있다.
- 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
- 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

ㅁ 객체지향 프로그래밍

- 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
- 가장 대표적인 언어로 Java가 있다.
- 캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.
- 절치지향 언어보다 실행속도가 느리다.
 

 

[ RESTful API ]
REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 차원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다. RESTful API는 아래와 같은 것들로 구성됩니다.

 

Resource(자원, URI)
Method(요청 방식, GET or POST 등)
Representation of Resource(자원의 형태, JSON or XML 등)
 

[ 함수형 프로그래밍 ]
함수평 프로그래밍의 가장 큰 특징은 immutable data와 first class citizen으로서의 함수입니다. 함수형 프로그래밍은 부수효과가 없는 순수 함수를 이용하여 프로그램을 만드는 것이다. 부수 효과가 없는 순수 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미합니다.

 

 

[ 메모리 구조 ]


![image](https://user-images.githubusercontent.com/62640332/149622125-1a04dd83-2612-4b6d-8581-8e1e3e3864b4.png)

- 코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부릅니다. 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됩니다.

- 데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역입니다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.
힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부릅니다. Java에서는 가비지 컬렉터가 자동으로 해제해줍니다. 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됩니다.

- 스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역입니다. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 합니다. 스택 영역은 함수의 호출이 완료되면 소멸합니다. 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됩니다.
 

 

[ Parameter와 Argument의 차이 ]
 

- Parameter: 함수를 선언할 때 사용된 변수
- Argument: 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값
 

 

[ Call By Value와 Call By Reference 차이 ]
 

ㅁ Call By Value

- 인자로 받은 값을 복사하여 처리하는 방식
- Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존된다.
- 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어난다.

ㅁ Call By Reference
- 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
- 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
- 원래의 값에 영향을 주는 리스크가 존재한다.
 

예를 들어 아래와 같은 코드가 있다고 할 때, a라는 새로운 변수가 생성되어 Call By Value로 전달되기 때문에 메모리를 많이 사용하지만 a를 변경하여도 원래 값인 f는 영향을 받지 않습니다.

```
public class Main {
     public static void main(String[] args) { 
         Foo f = new Foo("f");
          changeReference(f); // It won't change the reference! modifyReference(f); // It will modify the object that the reference variable "f" refers to! 
          }

        public static void changeReference(Foo a) {
             Foo b = new Foo("b"); a = b;
              } 
              
        public static void modifyReference(Foo c) { 
            c.setAttribute("c"); 
            } 
        }
```

![image](https://user-images.githubusercontent.com/62640332/149622158-51437743-1d5b-42c8-ade6-93cf790a8d07.png)


[ 프레임워크와 라이브러리 차이 ]
 

- 라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다.
  
- 프레임워크: 전체적인 흐름을 자체적으로 제어한다.

프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됩니다.

 

 

[ 병렬 처리 프레임워크의 종류와 특징 ]
 

ㅁ Hadoop

- HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받는다.
- 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있다.
- 하지만 File I/O를 기반으로 작동하기 때문에 처리 속도가 느리다.

ㅁ Spark

- In-Memory 상 에서 데이터를 주고받고 연산을 수행한다.
- 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠르다.
- 하지만 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 한다.
 

 

[ 동기와 비동기의 차이 ]
 

ㅁ 동기(Synchronous) 방식

- 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
- 순서에 맞추어 진행되기 때문에 제어하기 쉽다.
- 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다.
- 동기 방식의 예시로는 콜센터 종업원이 일을 처리하는 방식이 될 수 있다. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행할 수 있다.

ㅁ 비동기(Asynchronous) 방식

- 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
- 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있다.
- 작업이 완료된 결과를 제어하기 어렵다.
- 비동기 방식의 예제로는 이메일이 있다. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보낼 수 있다. 
 

[ SQL Injection ]
SQL Injection이란 공격자가 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL을 실행하도록 하는 웹해킹기법입니다. 예를 들어 아래와 같은 간단한 SQL 문이 있을 때 INPUT1에 'OR 1=1--을 넣는 것입니다.

```
SELECT * FROM USER WHERE ID = 'INPUT1' AND PASSWORD = 'INPUT2' SELECT * FROM USER WHERE ID = '' OR 1=1 --INPUT1' AND PASSWORD = 'INPUT2'
```

1. 프로그래밍 공통 - 고급
[ 메세지 큐(Message Queue)란? ]
메세지 큐(Message Queue)란 Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템으로, 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해준다. 메세지 큐에서는 Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리하게 된다. 메세지 큐에는 Kafka, Rabbit MQ, AMPQ 등이 있다.

 

[ Docker(도커)와 Kubernates(쿠버네티스) ]
Docker는 컨테이너 기반의 가상화 기술입니다. 기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 했습니다. 하지만 이러한 방식은 상당히 무겁고 느려 한계가 많이 있었습니다.

그래서 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장하게 되었고, 도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장하게 되었습니다.

 

 

[ Docker(도커)의 장/단점 ]
- 장점
  
    - 쉽고 빠른 실행 환경 구축
    - 하드웨어 자원 절감
    - Docker Hub와 같은 공유 환경 제공


- 단점
    - 개발 초기의 오버헤드
    - Linux 친화적
 

[ TDD(Test-Driven Development) ]
TDD(Test-Driven Development)는 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로, 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 의미합니다.

개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 하기 때문에 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힙니다.

 

 

[ DDD(Domain-Driven Design) ]
DDD(Domain-Driven Design)는 실세계에서 사건이 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법입니다. 옷 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있습니다. 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다. 도메인 주도 설계에서 도메인은 각각 분리되어 있는데, 이러한 관점에서 MSA(MicroService Architecture)를 적용하면 용이한 설계를 할 수 있다. DDD에서는 같은 객체들이 존재할 수 있는데, 예를 들어 옷 구매자의 입장에서는 (name, price)와 같은 객체 정보를 담지만, 판매자의 입장에서는(madeTie, size, madeCountry) 등이 있을 수 있습니다. 즉, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD입니다.

![image](https://user-images.githubusercontent.com/62640332/149622176-2d551786-b724-4ba3-b4c8-90f72ddc6ad0.png)



[ MSA란? ]
MSA(Microservice Architecture)는 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다. MSA는 1개의 시스템을 독리접으로 배포가능한 각각의 서비스로 분할합니다. 각각의 서비스는 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성합니다.


![image](https://user-images.githubusercontent.com/62640332/149622181-9d8df6db-29ae-4acc-b01b-9f918970777d.png)

장점
일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않는다.
각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
서비스의 확장이 용이하다.
단점
서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어렵다.
서비스 간에 RESTful API로 통신하기 때문에 그에 대한 비용이 발생한다.
서비스간의 호출이 연속적이기 때문에 디버깅이 어렵다.


<h1>2. 자료구조</h1>
[ 자료구조와 알고리즘 ]
자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고, 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임입니다.

 

 

[ 스택, 큐, 트리, 힙 구조 설명 ]

- 스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조이다.
  
- 큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다.


- 트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합하다.


- 힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리이다.


![image](https://user-images.githubusercontent.com/62640332/149622209-bfc82f8d-dc06-41fd-bdc9-d7f486ffde26.png)

[ 우선순위 큐와 내부 구조 및 시간복잡도 ]
우선순위큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다.

 

 

[ 해시 테이블와 해시 테이블의 시간 복잡도 ]
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다. 해시 테이블은 Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.

![image](https://user-images.githubusercontent.com/62640332/149622223-17f218b9-10c9-4bfb-9775-8960cf2a0989.png)


해시 테이블은 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다. 하지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가할 수 있습니다.

 

 

[ LinkedList와 ArrayList 차이 ]
ArrayList는 데이터들이 순서대로 늘어선 배열의 형식을 취하고 있지만, LinkedList는 자료의 주소값으로 서로 연결된 형식을 가지고 있습니다. 이러한 구조에 의해 둘은 각각의 장단점을 가지고 있습니다.

 

ㅁ ArrayList
- 원하는 데이터에 무작위로 접근할 수 있다.   
- 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.   
- 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸린다.    


ㅁ LinkedList
- 리스트의 크기에 영향 없이 데이터를 추가할 수 있다.   
- 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.   
- 무작위 접근이 불가능하며, 순차 접근만이 가능하다.   

![image](https://user-images.githubusercontent.com/62640332/149622246-36a83238-5c4b-4f94-a451-ea6b3a9338f4.png)


[ 큐와 스택의 구현 ]
- 큐(Queue): Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하다. 하지만 List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋다.
  
- 스택(Stack): List로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 Array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, Array로 구현하는 것이 좋다.

[ AVL 트리 ]
AVL 트리란 한 쪽으로 값이 치우치는 이진 균형 트리(Balanced Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리입니다. AVL은 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행합니다.

 

 

[ 레드블랙 트리 ]
레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠합니다. 그리고 연결된 노드들은 색이 중복되지 않도록 관리됩니다.



<h1>3. 알고리즘</h1>
[ 버블소트, 힙소트, 머지소트, 퀵소트, 삽입소트 ]
버블소트는 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 시간복잡도는 O(n2) 입니다.


![image](https://user-images.githubusercontent.com/62640332/149622257-b5e62107-df11-4a2e-ab9c-147ffc6134c2.png)

힙소트는 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘입니다. 힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우입니다. 시간복잡도는 O(nlog2n) 입니다.


<br>

![image](https://user-images.githubusercontent.com/62640332/149622268-194614a7-6b62-4326-b4ce-cc7adebdc52f.png)




<br>


ㅁ 머지소트는 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘입니다. 시간복잡도는 O(nlog2n) 입니다.

![image](https://user-images.githubusercontent.com/62640332/149622295-f43f2dfc-b30e-4868-9b18-c81661e99149.png)

ㅁ 퀵소트는 매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할합니다. 피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬을 합니다. 시간복잡도는 O(nlog2n) 이며 리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도가 O(n2) 까지 나빠질 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622391-344a0e63-82de-4d95-9738-590db2bdeae6.png)


ㅁ 삽입정렬은 두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다. 삽입 정렬의 평균 시간복잡도는 O(n2) 이며, 가장 빠른 경우 O(n) 까지 높아질 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622406-71336668-fad4-44e5-b7fd-f9e980bb83e5.png)

<br>


![image](https://user-images.githubusercontent.com/62640332/149622414-3e871e2e-fca4-4662-8e40-d4e06e2cff7b.png)


[ 동적 프로그래밍(Dynamic Programming)이란? ]
동적 프로그래밍(Dynamic Programming) 이란 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식입니다. 동적 프로그래밍에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상 시킬 수 있습니다. 

 

 

[ 동적 프로그래밍(Dynamic Programming)의 두 가지 조건 ]
동적 프로그래밍(Dynamic Programming)으로 문제를 해결하기 위해서는 주어진 문제가 다음의 조건을 만족해야 한다.

 

Overlapping Subproblem(중복되는 부분문제): 주어진 문제는 같은 부분 문제가 여러번 재사용된다.
Optimal Substructure(최적 부분구조): 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다.
 

 

[ 재귀 알고리즘과 재귀의 시간 복잡도 ]
재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘입니다. 재귀 알고리즘은 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요합니다.

팩토리얼을 계산하는 재귀 함수에서는 T(n) = T(n-1) + c (C는 n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 아래와 같이 O(n)이 됨을 보일 수 있습니다.

```
T(n) = T(n-1) + c
 = T(n-2) + 2c = T(n-3) + 3c
  = …… 
  = T(2) + (n-2)c 
  = T(1) + (n-1)c ≤ c + (n-1)c 
  = c + cn - c 
  = cn --> O(n)

```
<br>
[ 팩토리얼의 재귀/반복문 손코딩 ]

```
private static int recursiveFactorial(int num) { 
    if(num > 1){ 
        return recursiveFactorial(num - 1) * num; 
     } 
     return 1;
}
private static int loopFactorial(int num) {
     int answer = 1;
      for (int i = 2;
       i <= num; i++) {
            answer *= i; 
            }
     return answer; }

```

[ 피보나치 수열 재귀/반복문 손코딩 ]

```
private static int recursiveFibonacci(int index) { 
    if (index <= 2){
         return 1;
          } 
          return recursiveFibonacci(index - 1) + recursiveFibonacci(index - 2); 
          } 
private static int loopFibonacci(int index) { 
    int answer = 1;
    int before = 1;
    int temp; for (int i = 2; i < index; i++) {
        temp = answer;
        answer += before;
        before = temp;
        }
        return answer; 
    }
```


1. 알고리즘 - 고급
[ n개의 배열에서 k(k<=n) 번째로 큰수를 찾는 알고리즘 ]
이러한 문제를 해결하기 위해 일반적으로 퀵정렬을 사용합니다. 하지만 퀵정렬을 사용하면 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 됩니다. 퀵선택 알고리즘은 퀵정렬을 한 후에 피봇과 K를 비교하여 아래와 같이 수행합니다.

pivot의 인덱스가 k와 같은 경우 : 그대로 그 인덱스의 값을 리턴하면 된다.
pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스+1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다.
pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스-1까지 다시 Partition함수에 넘겨준다.
퀵정렬 알고리즘과의 다른 점은 예를 들어 Pivot의 인덱스가 7이고 K가 5인 경우에, 피봇의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행하는 것입니다.

이러한 이유로 퀵선택 알고리즘의 시간복잡도는 n+n/2+4/n+....1=O(n) 입니다.


![image](https://user-images.githubusercontent.com/62640332/149622579-579b43de-6d17-43ee-9d63-2c11966c4f51.png)


[ 허프만 코딩이란 ]
허프만 코딩은 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여합니다. 허프만 코드는 접두부 코드와 최적 코드를 사용합니다.

- 접두부 코드: 문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드   
- 최적코드: 인코딩된 메세지의 길이가 가장 짧은 코드   

![image](https://user-images.githubusercontent.com/62640332/149622589-ebef4c85-3d84-460e-b9ab-362874104afc.png)


[ 특정 수 이하의 3과 5의 배수의 합 구하기 손코딩 ]

```
private static int addMultipleOf3And5(int maxNum) {
    int div = maxNum / 3;
    int sum3 = (1 + div) * div * 3 / 2 ;
    div = maxNum / 5;
    int sum5 = (1 + div) * div * 5 / 2 ; div = maxNum / 15;
    int sum15 = (1 + div) * div * 15 / 2 ;
    return sum3 + sum5 - sum15;
    }
```

<h1>4. 네트워크</h1>
[ 웹 동작 방식 ]

![image](https://user-images.githubusercontent.com/62640332/149622626-ffc809bf-1ad9-45b3-99b3-53f28149b88a.png)


- 사용자가 브라우저에 URL을 입력
- 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
- HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함
- TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨
- 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함
- TCP/IP 연결을 통해 요청한 컴퓨터로 전송
- 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨


[ TCP와 UDP 차이 ]
TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정합니다. 그렇기 때문에 높은 신뢰성을 보장하지만 속도가 비교적 느리다는 단점이 있습니다. UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있습니다. 하지만 수신 여부를 확인하지 않기 때문에 속도가 빠릅니다. TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.


![image](https://user-images.githubusercontent.com/62640332/149622638-0b6ab9ea-c022-44fc-a7cb-5187ddc75f40.png)

[ GET과 POST 차이 ]
GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다. URL에 데이터가 노출되기 때문에 보안적으로 중요한 데이터를 포함해서는 안됩니다.

POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다. 완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET보다는 안전합니다.


![image](https://user-images.githubusercontent.com/62640332/149622649-6106b759-1eb4-450c-bd41-8a9b1af0a30c.png)

[ 공인 IP와 사설 IP 차이 ]
 

- 공인 IP
  - 전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소
  
  - 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능하다.
  
  - 그에 따라 방화벽 등과 같은 보안 설정을 해주어야 한다.


- 사설 IP
- 어떤 네트워크 안에서 사용되는 IP주소
  
- IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소이다.
  
- 별도의 설정 없이는 외부에서 접근이 불가능하다.
 

 

[ 웹 접근성의 국제표준 ]

웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미합니다. 웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정하였습니다.


![image](https://user-images.githubusercontent.com/62640332/149622657-4442c454-22c5-4ec0-a755-6514d12ee09c.png)

- 7 계층(응용 계층): 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층   
- 6 계층(표현 계층): 데이터의 형식(Format)을 정의하는 계층   
- 5 계층(세션 계층): 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층   
- 4 계층(전송 계층): 최종 수신 프로세스로 데이터의 전송을 담당하는 계층   
- 3 계층(네트워크 계층): 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층   
- 2 계층(데이터링크 계층): 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층   
- 1 계층(물리 계층): 데이터를 전기 신호로 바꾸어주는 계층   


[ HTTP 프로토콜이란? ]
HTTP(Hyper Text Transfer Protocal)이란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다. HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동합니다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성됩니다.


![image](https://user-images.githubusercontent.com/62640332/149622679-fc381ca4-0750-49df-a63e-b57cb13a31c3.png)


[ HTTP vs HTTPS ]
HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. HTTPS는 자신의 공개키를 갖는 인증서를 발급하여 보내는 메세지를 공개키로 암호화하도록 하고 있습니다. 공개키로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 기업을 제외한 누구도 원본 데이터를 얻을 수 없습니다.


![image](https://user-images.githubusercontent.com/62640332/149622692-e775cafc-8493-4ae5-b51e-583e03590728.png)


[ 3 Way-Handshake ]
3 Way-Handshake란 TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태임을 확인합니다.


![image](https://user-images.githubusercontent.com/62640332/149622705-b5e0f61b-02a1-4f3c-8b28-c0d734d7e689.png)

[ HTTP 1 vs HTTP 2 ]
HTTP1은 기본적으로 연결당 하나의 요청/응답을 처리하여 다음과 같은 문제를 가지고 있었습니다.

HOL(Head Of Line) Blocking (특정 응답 지연): 클라이언트의 요청과 서버의 응답이 동기화되어 지연 발생
RTT(Round Trip TIme) 증가 (양방향 지연): 패킷 왕복 시간의 지연 발생
헤더 크기의 비대: 쿠키 등과 같은 메타데이터에 의해 헤더가 비대해짐
 

그리고 HTTP2는 다음과 같은 기술을 사용하여 HTTP1의 성능 문제를 해결하였습니다.

Multiplexed Streams: 하나의 커넥션으로 여러 개의 메세지를 동시에 주고 받을 수 있음
Stream Prioritization: 요청온 리소스간의 의존관계를 설정하여 먼저 응답해야하는 리소스를 우선적으로 반환함
Header Compression: 헤더 정보를 HPACK 압축 방식을 이용하여 압축 전송함
Server Push: HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있음


![image](https://user-images.githubusercontent.com/62640332/149622716-0a8dd6aa-d01d-426a-9555-e52ecb500a61.png)


<h1>5. 운영체제</h1>
[ Byte Ordering이란 ]   
: Byte Ordering이란 데이터가 저장되는 순서를 의미합니다. Byte Ordering의 방식에는 빅엔디안(Big Endian)과 리틀엔디안(Little Endian)이 있습니다.

- Big Endian
    - MSB가 가장 낮은 주소에 위치하는 저장 방식   
    - 네트워크에서 데이터를 전송할 때 주로 사용됨   
    - 가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.   


- Little Endian
    - MSB가 가장 높은 주소에 위치하는 방식   
    - 마이크로프로세서에서 주로 사용된다.   
    - 가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산을 할 수 있다.    

![image](https://user-images.githubusercontent.com/62640332/149622781-bb37d957-69d6-40e0-b5c9-4b3a4e4c2f2b.png)

[ 메모리란 ]
메모리는 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간입니다. 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리됩니다.

 

 

[ 프로세스와 쓰레드의 차이 ]
 

ㅁ 프로세스
- 정의: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

- 특징
    - 운영체제로부터 독립된 메모리 영역을 할당받는다. (다른 프로세스의 자원에 접근 X)
  
    - 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.

    - 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.
 
ㅁ쓰레드
- 정의: 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위

- 특징
  
    - 쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다. (Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.)

    - 쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.
     
    - 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.

![image](https://user-images.githubusercontent.com/62640332/149622796-85a5d525-7b3d-4c3e-ae00-6763332e47ad.png)


[ 컨텍스트 스위칭(Context Switching)이란? ]
Context Switching이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다. Context Switching는 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다. 여기서 인터럽트란 CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 말합니다.

![image](https://user-images.githubusercontent.com/62640332/149622884-afd43165-66c0-4c2f-a165-95b36f0c8d8a.png)


[ 멀티 프로세스 VS 멀티 쓰레드 ]
 

- 멀티 프로세스   
: 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것

  - 특징

    - 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행된다.

    - Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다.

    - 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.


- 멀티 쓰레드   
: 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것

   - 특징

      - 프로세스를 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있다.

      - 쓰레드는 메모리를 공유하기 때문에, 통신이 쉽고 자원을 효율적으로 사용할 수 있다.

      - 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받는다.

      - 여러 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있다.
 

[ 데드락(DeadLock) 이란? ]   
데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다. 예를 들어 다음과 같은 상황에서 데드락이 발생할 수 있습니다.

자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됩니다.

 

[ 멀티 쓰레드 프로그래밍 작성 시 유의점 ]   
멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의해야 합니다.

 

[ 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 ]   
뮤텍스는 Locking 메커니즘으로 락을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제할 수 있습니다. 하지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.

 


[ CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법 ]   
이러한 문제를 해결하기 위해 메모리를 계층화하여 병목현상을 해결하고 있습니다. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있습니다.


1. 운영체제 - 고급
[ 가상메모리와 페이지폴트 ]

![image](https://user-images.githubusercontent.com/62640332/149622946-5a6d1c48-9d57-4880-be07-c099c6c47a7d.png)


가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. 

OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. 

CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다(Valid bit를 통해 확인). 

이것을 페이지 폴트라고 하는데 프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다.

 가상메모리는 하드디스크에 저장되어 있기 때문에, 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.

 

 

[ 페이지 교체 알고리즘과 LRU(Least Recently Used) ]
LRU(Least Recently Used)는 페이지를 교체하기 위한 알고리즘 중 하나입니다.

페이지를 교체하는 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문입니다. 페이지 교체를 위해서는 실제메모리에 존재하는 페이지를 가상메모리로 저장한 후에, 가상메모리에서 조회한 페이지를 실제메모리로 로드해야 됩니다. 그렇다면 어떤 실제메모리의 페이지를 가상메모리로 희생시킬 것이냐에 대한 문제가 발생하는데, 이때 사용하는 알고리즘 중 하나가 LRU(Least Recently Used) 알고리즘 입니다.

LRU 알고리즘은 실제메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식입니다. 그 외에도 먼저 적재된 페이지를 희생시키는 FIFO(First In First Out) 알고리즘이나 LRU 알고리즘을 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 있습니다.


[ 인덱스(index)란? ]
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.

데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

만약 Index를 적용하지 않은 컬럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행된다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

 

 

[ 인덱스의 자료구조 ]
ㅁ 해시 테이블
- 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
  
- 시간복잡도가 O(1)이라 검색이 매우 빠르다.
  
- 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.

ㅁ B+Tree
- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. 
  
- BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
  
- 해시 테이블보다 나쁜 O(log2n) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.
 

 

[ DB 정규화 ]
- 제1정규형: 모든 속성 값이 원자 값을 갖도록 분해한다.

- 제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.
(여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미한다.)

- 제3정규형: 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.
(여기서 이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A,B와 B,C로 분해하는 것이 제3정규형이다.)

- BCNF 정규형: 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.
 

[ 트랜잭션(Transaction)이란? ]
하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다.

 

 

[ 트랜잭션의 ACID란? ]
- 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.

- 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.

- 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.

- 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
 

[ 이상 현상의 종류 ]
- 삭제 이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
  
- 삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
  
- 수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상
 

[ DB 락의 종류 ]
DB 락은 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구이다.

- 공유락(LS, Shared Lock): 트랜잭션이 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

- 베타락(LX, Exclusive Lock): 트랜잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음
 

[ RDBMS와 NoSQL 차이 ]
ㅁ RDBMS
2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스 

- 장점: 스키마에 맞추어 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.

- 단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.

ㅁ NoSQL   
: RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
- 장점: NOSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리할 수 있다.

- 단점: 중복된 데이터가 추가 가능하여, 이에 대한 관리가 필요하다.
 

 

1. 데이터베이스 - 고급
[ 힌트(Hint)란? ]
힌트란 SQL을 튜닝하기 위한 지시구문입니다. 옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우에 개발자가 직접 최적의 실행 계획을 제공하는 것입니다. 힌트는 아래와 같이 SELECT 다음에 작성할 수 있으며, INDEX, PARALLEL 등 다양한 힌트절이 있습니다.


```
# 사용가능한 힌트절: PARALLE, INDEX, FULL ...
 SELECT /*+ [힌트절] */
```

[ 클러스터링 vs 리플리케이션 ]

ㅁ 리플리케이션   
: 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
비동기 방식으로 노드들 간의 데이터를 동기화한다.

- 장점: 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없다.

- 단점: 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있다.

ㅁ 클러스터링   
: 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식이다.
동기 방식으로 노드들 간의 데이터를 동기화한다.

- 장점: 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영할 수 있다.

- 단점: 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replciation에 비해 쓰기 성능이 떨어진다.
 

[ 데이터베이스 튜닝과 방법 ]
DB 튜닝은 테이터베이스의 구조나 데이터베이스 자체, 운영체제 등을 조정하여 데이터베이스 시스템의 성능을 향상시키는 작업을 의미합니다. 튜닝은 DB 설계 튜닝 -> DBMS 튜닝 > SQL 튜닝의 단계로 진행할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622972-5a8f3a01-4434-4c3c-9cfc-2b42e0d6b8b4.png)



