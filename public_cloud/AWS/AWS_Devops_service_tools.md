- [전체적인 설명](#개요)
- [stack](#stack)


---

#전체적인 설명

- CI/CD : 개발자가 코드 변경사항을 중앙 repository에 정기적으로 병합하고, 빌드와 테스트 과정을 거쳐 프러덕션에 릴리스하는 각 과저을 포함한다.
- IaC: 버전 제어, 지속적 통합과 같은 코드 및 소프트웨어 개발 기법을 사용하여 인프라를 프로비저닝하고 관리

![image](https://user-images.githubusercontent.com/62640332/155364530-06abcc20-8a38-4274-a025-9ca8028b445a.png)



애플리케이션을 관리한다는 것은 로직을 구성하는 코드 뿐만아니라 해당 애플리케이션 인프라 관리도 포함한다.

이는 AWS위에 웹 애플리케이션을 구축했다고 가정한다면, VPC, EC2, RDS등도 관리해야한다는것이 된다.

![image](https://user-images.githubusercontent.com/62640332/155365137-ee2bad50-f1c1-4b8c-8c8b-769f9cd0b93f.png)

초보자는 GUI 방식이 좋지만, 자동화 하기위해서는 CLI 방식으로 해야한다.

 CLI 명령어 똑같이 재현 어려움, SDK 자원의 자동생성을 지원하고 벌크형태로 만드는게 가능하지만, aws에 대한 엑세스 용도로만 사용되는경우가 대부분

 그래서 AWS  CloudFomration 이나 AWS Cloud Development Kit(AWS CDK)로 만드는게 devops의 모범사례에 적합하다.

 


 대부분 devops팀이 겪는 3R problem
 
 - repeatability(반복성)
 - reproducibility(재현성)
 - reliability(신뢰성)

사람들이 같은 반복적으로 같은 환경 만들시 휴먼에러로 가끔 다른 결과 나오는 경우가 있다. 또 개발환경에서는 문제가 없었지만 프러덕션 환경에서는 문제 발생하는 경우가 있다.

이러한 인프라 관리에서 발생할수 있는 문제를 IaC 관리를 통해 아예 제외시킬수 있다.

IaC는 소스코드처럼 버전닝 및 관리가 되어, 환경내에 일어나는 일 추적이 가능하다. 즉 변경기록과 롤백이 비교적 쉽다.

또한 동일한 config 파일, 코드만 있다면 여러개의 환경을 만들어 낼수 있다.

AWS 에서 IaC 방식 : AWS CloudFormation, AWS CDK
Third-pary tool : HashiCorp Terraform, puppet

![image](https://user-images.githubusercontent.com/62640332/155366962-ed6c89dd-d684-4b10-8bbc-db8c28e132a0.png)

앱 코드, 인프라 템플릿 작성후 배포하고, 실제환경에서 사용하고 다시 최적화를 위해 반복


![image](https://user-images.githubusercontent.com/62640332/155367166-a0532aeb-e247-47bb-89f2-2df1b6eff307.png)

AWS resource를 모델링하고 설정하여 리소스 관리에 대한 신경을 경감시키고, 해당 리소스위에 애플리케이션에 집중할수 있게하는 서비스

아마존 EC2, RDS 관련값을 기재한 템플릿을 생성하면 클라우드 포메이션이 해당 리소스에 프로비저닝과 구성을 담당한다.

클라우드 포메이션을 사용하면 aws 리소스를 사용자가 개별적으로 생성하고 구성할 필요가 없으며, 관련된 dependency에 대해 파악할 필요가 없어진다.

![image](https://user-images.githubusercontent.com/62640332/155367900-879e7a51-7d96-4b27-935b-dc795ba6406a.png)

![image](https://user-images.githubusercontent.com/62640332/155367949-05e92a3a-8b5f-4db8-bc21-e799b2c8332e.png)

코드는 템플릿이라는 파일에 기록이 되고, 스택은 탬플릿을 통해 발생된다.

탬플릿은 주로 애플리케이션을 위한 리소스를 정의합니다. 리소스의 상태를 설명

각 리소스는 사용가능한 속성에 따라 구성되고, 종속석을 명시적으로 선언하거나 암묵적으로 검색 가능하다.

클라우드 포메이션은 이러한 의도를 API 호출로 변환하여 리소스를 프로비저닝 한다.

위의 예시는 Yalm 

- 버전은 선택사항 
- 설명은 상세히 적는것 중요
- 파라미터는 해당 탬플릿 사용하는 사용자에게 하는 질문
- 매핑은 스스로 채워지는 파라미터와 같다. ex) 매핑마다 리전마다 구동할 AIM을 명시해 놓으면 서울 리전 안에서 새로운 탬플릿 만들때 실행할 AIM을 자동적으로 선택된다.
- 조건의경우 참인경우에만 리소스 생성
- 리소스는 탬플릿에서 유일하게 필수로 작성해야하고, 생성할 aws 리소르를 기재하는 부분
- 아웃풋은 리소스가 프로비저닝된 후에도 도출될수 있는 값

![image](https://user-images.githubusercontent.com/62640332/155369312-a21a1a43-31da-4332-a2c0-09b4c5df9e15.png)

#stack

![image](https://user-images.githubusercontent.com/62640332/155369769-f6dc5735-d9da-4447-9648-7cab30c8b1e5.png)

![image](https://user-images.githubusercontent.com/62640332/155369871-0d763734-b57b-4792-be21-ae3aa4fbdb07.png)

![image](https://user-images.githubusercontent.com/62640332/155369990-f010aad0-9fd8-4391-86a7-2e225a1297ad.png)

이미 aws 해비 사용자라면 , 여러개의 개정을 가지고, 하나의 개정에서 여러개의 리전 사용할것이다. 이떄 aws cloud formation을 어떻게 확장해서 사용할수 있을까?

=> Stack set

statck set 들을 위한 stack을 생성 가능하다. 스택셋 만든후에는 언제든지 추가 계정 및 리전에 대한 스택을 추가 가능하다.



탬플릿을 생성후 바로 클라우드 포메이션에 업로드는 가능하지만, 해당  탬플릿이 에러가 발생한다면 리소스가 프로비저닝이 불가능해진다.

로직 단에서의 에러는 탬플릿 작성전에 완료 되어야한다. ==> 오픈소스 툴인 cfn-lint 

해당 툴 사용하면 탬플릿 배포전에 에러를 인지하고 수정이 가능해진다.

![image](https://user-images.githubusercontent.com/62640332/155370837-e0326487-1ab7-4e2a-b791-5768b721e7b8.png)


처음 소규모의 리소스 프로비저닝에는 하나의 플랫폼에 관련 정보를 모두 명시하는것이 효율적이지만, 워크로드의 범위가 커지면

계층화된 아키텍처 방식으로 만들어야 한다. 

생김새가 비슷하여 cloud formation cake 라고도 불린다. 성격이 비슷하고, 리소스의 라이프 사이클 비슷한것 끼리 묶어서 사용해야 한다.

![image](https://user-images.githubusercontent.com/62640332/155371098-19e7e379-84ed-4423-a59a-8e7593abb4ed.png)

예를 들어 네트워크 보안시 애플리케이션 바이너리 파일 및 데이터베이스 변경시 함께 변경될 가능성 적음

이렇게 각각 분리하면 실수로 자원 삭제 막을수 있고, 필요한 부분만 업데이트 가능하여 이후 리소스 테스트 및 트러블 슈팅 용이 해진다.

IaC 이상적인 가정은 리소스 관련 작업은 IaC를 통해서 하는것이다. 그러나 급하게 일부 변경사항 있을경우 수동으로 리소스 컨트롤 한다.

이와같이 관리되지 않는 변경은 실행중인 스택의 구성이 템플릿에서 드리프트 되었기 때문에 기존에 의도한 상황과 실제 리소스 상태가 불일치 하게 된다.

==> 드리프트 감지기 사용 한다. 

![image](https://user-images.githubusercontent.com/62640332/155371624-bd31a8bd-50e1-46d1-ab69-6cd7a424e94b.png)


db의 패스워드와 같이 중요정보는 하드코딩하지 않는다. 이와같이 빨간글씨 처럼 aws 시스템 매니저 파라미터 스토어에 저장하고 불러오는것 중요

![image](https://user-images.githubusercontent.com/62640332/155371822-f02b0e2b-0c5f-41c2-b2f8-43cbf2ae343c.png)

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155372016-4f2fb894-7283-48ee-8496-199c7fb340d8.png)

![image](https://user-images.githubusercontent.com/62640332/155372086-5a23c594-4a74-438b-aa71-982b7a6976b5.png)

- core framework를 이용하여 하나이상의 stack 포함된 앱을 만들고 구성 가능

stack은 여러 리소스를 포함하고, one to one 클라우드 포메이션 스택과 맵핑된 단위를 의미

- AWS Construct Library는 aws에서 특정 서비스에 대한 리소스를 생성하기 위해 만들어진 구성요소의 집합으로, 프로젝트에 필요한 dependency만 사용할수 있다.

또한, 사용편의성 및 빠른 반복주기에 적합하도록 모범 사례를 기반으로 만들어져 있다.

- AWS CDK CLI는 core framework와 상호작용하며, 프로젝트에 스트럭쳐를 초기화하고 배포된 상태와 배포할 상태의 차이점을 비교하여, aws 환경에 쉽게 리소스 반영할수 있도록 지원합니다.

![image](https://user-images.githubusercontent.com/62640332/155372817-96c2c14b-518b-4166-ba55-a842eca4fce5.png)

aws cdk 는 해당 소스코드를 컴파일하여 어셈블리 언어 형태인 클라우드 포메이션 템플릿을 만들고

이를 클라우드 포메이션 스택에 배포하여 안전하고 반복가능한 형식으로 클라우드 리소스를 프로비저닝 합니다.

사용자는 첫번째로 CDK init 명령어 시작하고 그와 동시에 cdk는 특정 프로그래밍언어에 대한 프로젝트 구조를 생성

사용자는 앱을 만들고, 스택, 컨스트럭트, 리소스를 추가할수 있다.

그와 관련된 작업이 완료되면 프로젝트를 빌드 합니다. 예를 들어 타입스크립트를 사용한다면 npm run 명령어 사용

그리고 사용자는 작성한 코드를 클라우드 포메이션 탬플릿으로 컴파일 해야한다.

이떄 cdk synth를 사용하면 탬플릿과 에셋이 생성된다. 

마지막으로, cdk deploy를 통해 클라우드 포메이션이 적용되면,   aws 계정에 리소스 프로비저닝 된다.

이후 소스코드를 수정하고 반영시 빌드 및 디플로이를 반복하되, 기존의 프로비저닝된 리소스와의 변경사항을

체크하기 위해 디플로이 이전 cdk diff 명령어 사용한다. 

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155470656-7442145f-39dc-45a7-9c02-050d0604e3e5.png)



왼쪽은 CDK 오른쪽 클라우드 포메이션으로 작성한것.

CDK는 프로그래밍 언어의 모든 기능을 활용하여 aws 인프라를 코드로 정의하는 개발자 중심의 도구 키트

클라우드 포메이션을 활용하여, 안전한 배포, 자동 롤백, 드리프트 감지 등 클라우드 포메이션 이점을 계속 이용가능하다.

실제 애플 vs 애플 비교한다면 클라우드 포메이션으로 리소스에 대한 코드를 작성할때보다 CDK로 작성할때

더 적은 코드로 같은 결과 도출 가능하다. 그러나 프로래밍 언어 기술이 필요하기 때문에, 기술이 없다면 러닝커브 

발생할수 있다. ==> 사용자에게 적합한 툴 사용하면 된다.

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155470896-aa9e8c05-adf3-46ec-9b15-ae2902a62b37.png)

지속적 통합/배포의 레이아웃 입니다.

개발자가 소스코드를 repository에 push 하면, 일련의 과정을 거쳐  프러덕션 환경에 반영됩니다.

이러한 모든 프로세스 자동화 하는것이 devops의 목적


![image](https://user-images.githubusercontent.com/62640332/155471098-4499ce4b-e832-422f-bb00-85647f8ed75f.png)



![image](https://user-images.githubusercontent.com/62640332/155471320-4d5c3f01-4166-4620-b121-007e7ffec415.png)



처음 개발 코드를 작성하는 환경부터 aws 가능합니다.

aws cloud9을 사용하면,  웹브라우저에서 코드를 작성하고 실행하고 디버깅 가능하다.

클라우드 9은 클라우드 기반 IDE로 프로그래밍 언어로, 필수 언어가 패키징 되있고, 웹브라우저에서 실행하기때문에

어디서든 작업을 진행할수 있다. 그리고, 개발 환경이 팀과 공유하면 코드협업 쉬워진다.

그리고 aws 위에서 개발위한 sdk, 라이브러리, 플러그인 제공한다.

또한, 터미널 창에서 aws 직접적으로 엑세스하여 컨트롤이 가능하다.

클라우드9으로 코드작성하고 작성한 코드를 저장소에 반영하면, 사전에 구축된 코드 파이프라인 동작하고

최종적으로 애플리케이션 변경되는 형태 이다. 해당 애플리케이션에 모니터링 붙여서 현제 나의 애플리케이션이

잘 작동하고있는지, 최적화할 부분 있는지 확인이 가능하다.


![image](https://user-images.githubusercontent.com/62640332/155476612-e7ffc29d-ccf1-4cf9-b0ca-7e1a46b02104.png)

CI/CD 에서 소스 빌드 테스트 디플로이를 하나의 큰 묶음으로 파이프라인으로 표현

완전 관리형 이기때문에 사용자는 인프라 관리에 대해 신경쓸 필요 없다.


![image](https://user-images.githubusercontent.com/62640332/155479624-07b36e68-bff0-4785-9e3f-063054f2bd6c.png)

- 코드 파이프라인 구축시 각 스테이지에서 선택할수 있는 옵션

- 소스 스테이징 에서는 aws codecommit, github에서 소스 변경시 파이프라인이 트리거 가능

s3에 아티팩트 들어올떄, 콘테이너 워크로드 사용시 컨테이너 이미지 변경시에도 파이프라인 트리거 가능

스케줄링 및 자원의 상태에 따라 트리거 가능

- 빌드 스테이징에서는 Jenkins 나 code build 부착 가능하며 선택사항

- 배포 스테이징에서는 EC2 인스터스, 온프레미스 서버, 람다, 아마존 ECS, fargate


![image](https://user-images.githubusercontent.com/62640332/155480269-350045ec-cbb4-4f5e-be6f-7303b444cdf0.png)

처음 소스코드 푸시 하면, 소스가 빌드되고, 최종적으로 aws 클라우드 포메이션에 변경분 반영

![image](https://user-images.githubusercontent.com/62640332/155480411-e18f96c4-c966-4c80-b170-31cb6349e95e.png)

![image](https://user-images.githubusercontent.com/62640332/155480434-1d8d7775-5a47-4e9c-aafe-c032b6e309d5.png)

개별적으로 파이프 라인 생성된다.

- CI
  
1. 새 코드가 체크인될 때 새 빌드를 자동으로 시작
2. 일관되고 반복 가능한 환경에서 코드 빌드 및 테스트
3. 배포에 사용할 아티팩트를 지속적으로 준비
4. 빌드 실패 시 피드백 루프를 최적화

<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155480650-4ed36663-738a-41f0-b862-c626c15724e6.png)


소스코드 컴파일, 유닛 테스트, 소프트웨어 패키지 생성까지 가능한 완전 관리형 빌드 서비스

빌드 볼륨에 맞춰 자동적으로 확장 가능하며, 여러 빌드를 동시에 병렬적으로 처리 가능

병렬 작업시 레이턴시 시간 줄일수 있는 이점을 가진다. 그리고, 빌드속도 향상위해 캐시기능 있음

코드 빌드를 통해 빌드 실행시 환경 정의해야 하는데, 여기서 빌드환경은 코드 빌드가 빌드 실행하기 위해 사용하는 OS, 프로그래밍 언어, 런타임, 도구의 조합 의미

AWS에서 환경 지원하지만, 사용자가 커스터마이징한 환경도 가능


![image](https://user-images.githubusercontent.com/62640332/155481259-67b21dd1-faae-4093-9381-0bc098ce77b5.png)

코드빌드를 실행위해서 빌드스팩.yaml 파일 작성해야 한다. 

빌드스팩 파일 에서  리포트 명시해논 파일 확인가능.

유닛 테스트 보고서를 만들기 위해 리포트의 결과 경로를 빌드스팩에 추가후,

코드 빌드 리포트에서  리포트 그룹 생성후, 관련 ARN 빌드 스펙에 붙여넣으면 유닛 테스트 세부사항 확인 가능

<br>
<br>

- CD

1. 테스트를 위해, 스테이징 환경에 새로운 변경 사항 자동 배포
2. 고객의 사용성에 영향을 미치지 않고 안전하게 프로덕션 환경으로 배포(실제 프로덕션 환경에서 제로다운 패치도 중요)
3. 고객에게 신속하게 제공: 배포 빈도를 높이고, 변경 리드 타임 및 변경 실패율 감소


일반적으로 빌드까지가 CI 영역,

CD의 경우 스테이징 환경까지가서 로컬 테스트를 넘어 다른 시스템과의 통합테스트, 부합테스트 등을 통해 최종적으로 프로덕션 아티팩트 만드는 과정

변경분을 에자일하게 반영하고, 변경실패율 감소하는것이 지속적 배포의 목표 => CodeDeploy

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155482140-2cb818dd-37b4-4fc3-9a17-546ad4f888df.png)


테스트환경, 스테이징환경, 프로덕션 환경에 있는 실제 인스턴스에 아티팩트 배포한다.

복잡한 업데이트를 간편하게 핸들링 가능, 배포중 다운타임을 최소화 가능하며, 여러 애러발생시 자동 롤백기능 지원

마지막은 배포 대상으로, 온프레미스의 경우 agent 설치하여 code deploy가 통신해서 진행한다.




![image](https://user-images.githubusercontent.com/62640332/155482687-fb7dd283-21e6-4525-a534-d02bf1bfd276.png)


codeDeploy 에도 appspec 파일 존재하며, 해당 파일 배포 진행방식 정의한다.

예를들어 파일에 정의된 일련의 수명주기 후크로 배포를 관리합니다.



![image](https://user-images.githubusercontent.com/62640332/155482807-bdaeff2a-bfd8-4beb-b49a-3ee40fed7c2d.png)


또한 배포속도 및 그룹도 조절 가능하다.

![image](https://user-images.githubusercontent.com/62640332/155482846-1547a275-60f1-459f-901b-80966bf631c9.png)

릴리즈 프로세스를 하나의 코드 파이프라인 구축의 예시 이다.

코드 변경분이 코드 커밋에 반영되고 유닛 테스트 실행한 파일이 코드 빌드를 통해 빌드가 된다.

그리고 canary 배포를통해 스테이징 환경에 코드 디플로이 되고, 로드테스트 실행후 프로덕션 환경에 배포 된다.

<br>
<br>
<br>

ㅁ AWS Lambda

AWS의 대표적인 서버리스 컴퓨팅 서비스인 Lambda는 완전 관리형 컴퓨팅 서비스로 상태 비저장 코드를 실행합니다.

대체로 1회성 용도의 프로그램인 주기적인 Job을 처리하는 Scheduler 역할로 사용하거나, Amazon S3 버킷 또는 DynamoDB 테이블의 데이터 변경, 또는 엣지 로케이션의 CDN에서 Lambda 형태로 처리하곤 합니다.

다만 제한사항으로 최대 15분 길이로 지침을 실행할수 있으며, 15분이 넘어가는 서비스는 컨테이너 기반 또는 EC2 기반으로 구성해야 합니다.

서버리스 컴퓨팅을 적용하면 애플리케이션 개발에 보다 집중할 수 있고 요청 시에만 컴퓨팅 리소스를 사용하여 비용 효율적인 시스템이라고 볼 수 있으며 특히 마이크로서비스 아키텍처와 같이 세분화 된 서비스에 보다 적합합니다.

<br>
<br>
<br>

 
ㅁ AWS API Gateway

: API Gateway는 마이크로서비스를 정의하는 API를 처리하는 핵심 Component로 단일 접점 역할을 담당하여 외부로 엔드포인트 노출을 차단할 수 있습니다.

API 서비스의 핵심과 답게 다양한 기능을 제공하며 주요 기능은 다음과 같습니다.

- 개발자에게 API 키를 생성하여 배포w
- CIDR을 활용하여 API에 대한 액세스 승인
- 프라이빗과 통합, Lambda와 통합 기능 지원
- 엔트포인트 노출 방지 역할
- DDoS 및 명령어 주입 공격으로부터 보호
- API Gateway 캐시 기능 제공


---


ECS - docker supported

EKS - kubernetes supported

두 개념 모두 container orchestration service

​

현 직장 업무로 외부 API를 콜하여 적재하는 서비스를 ECS로 등록하여 관리하고 있다. 이에 따라 AWS에서 제공하는 컨테이너 서비스를 전반적으로 살펴보고, ECS와 EKS의 차이를 파악해보고자 한다.

​

아래 그림은 아마존에서 제공하는 컨테이너 서비스를 단계별로 분류해둔 그림이다.


AWS Container Support Service

* Hosting : 컨테이너가 실행될 환경(Compatibilities)를 EC2/Fargate로 설정하는것.

1) EC2 : 프로세서, 스토리지, 네트워크에 대한 full control 권한을 가짐

2) Fargate : serverless container compute engine

​

Management단에서 ECS, EKS 두 가지 선택 옵션이 있는데, 어떤 차이가 있는지를 파악하기 위해 좀 더 리서치를 해보았다.


Spectrum of Abstraction Level

아마존에서 제공하는 가상화 레벨 도식화를 살펴보면,

- VM단에 해당하는 것이 EC2

- container로 해당하는 것이 EKS, ECS

- Lambda는 function이므로 가장 추상화가 되어있는 서비스

- Fargate는 provider space에 존재(=AWS에서 매니징)하는 서비스

로 정리할 수 있다.

ECS가 EKS보다 좀 더 가상화 레벨이 높은 것으로 분류되어있다.

Fargate는 추후 EKS에서도 지원된다는 점을 미루어보면, 리소스를 직접 Control하는 권한을 개발자 본인이 full로 가져갈지(EC2), AWS에 맡길지(Fargate)에 따라 선택이 가능한 듯 하다.

​

ECS와 EKS의 차이

우선 간단하게 정리하면 ECS는 EKS 대비 AWS 서비스와 자원을 더 활용하고,

EKS는 kubernetes가 지원하는 환경을 다 활용 가능한다는 차이점이 있다.

AWS 공식 독스에서는 ECS가 좀 더 simplicity를 추구가능하다고 표현한다.

주로 가격 정책, 네트워크와 Load Balancing에서 차이를 보인다고 한다.

​

1) 가격 정책

- ECS의 경우 EC2 런치 타입에 따른 추가적인 과금이 없음 (Pay-as-you-go)

- EKS의 경우 추가적인 비용 부담이 있음.

​

2) 네트워크

- ENI (Elastic Network Interface) 할당에 차이가 있음

- EKS는 EC2 instance내 단일 Pod 또는 여러개 Pod를 묶어 IP를 할당 받을 수 있음. 즉 네트워크를 공유

- ECS는 EC2 instance내 task별로 ENI를 할당받음

위 특성 때문에 개발하는 서비스의 컨테이너 사용 갯수가 많을수록 EKS가 효율적일 수 있음.

​

3) Load Balancing

- EKS는 별도로 Proxy를 두어 Pods 로드를 분산

- ECS는 단일 ALB를 사용

EKS의 경우 트래픽이 많아질경우 Node간 latency 늘어난다는 단점이 있다.

​

4) Compatibility

ECS는 AWS-only로 제공되는 서비스이기 때문에 다른 서비스 provider나 on-premise에서도 서비스를 운영하고 싶을 경우 EKS가 나은 선택일 수 있다. EKS는 어떤 infra 환경에서도 실행이 가능하기 때문이다.

---

EC2에 직접 K8s를 설치하는 것과 EKS 차이점.
 

[질문]

EC2에 쿠버네티스를 설치해서 사용하는 것이랑 

EKS를 사용하는 것의 주요 차이점, 장단점 등은 어떤 것들이 있을까요?

 

[답변]

EC2에서 쿠버네티스를 설치해서 사용하실 경우 

쿠버네티스의 마스터 노드에 위치한 

각종 컴포넌트(api server, etcd etc.) 등에 대한 고가용성도 고객이 직접 보장/관리 하셔야 합니다. 

하지만. eks를 사용하시는 경우 싱글태넌트로 고객별로 만들어진

 kubernetes master node를 저희가 직접 고가용성 관리를 하므로 관리 운영 부담이 현저히 줄어듭니다.


![image](https://user-images.githubusercontent.com/62640332/155871958-aed6c686-463f-4850-8c89-94f93dc6c1b8.png)



---

 ECR (EC2 Container Registry) 은 Docker Container 의 이미지를 저장하는 Repository 서비스이다. 기능은 Docker hub 의 Repository 서비스와 동일하다. 특별한건 없다. Docker Private Repository 구축하고 관리 하는 수고를 AWS 에 맡기는 Managed 서비스일 뿐이다. 



 장점이라고 한다면,

 Container 이미지를 S3 에 저장하기 때문에 고가용성이 유지되고, AWS IAM 인증을 통해 이미지 push/pull 에 대한 권한 관리가 가능하다는 것이다. 

---


ㅁ 데이터 스토어

데이터 스토어는 마이크로서비스에 필요한 데이터를 유지하는 데 사용됩니다.

세션데이터의 인기 스토어는 Memcached또는 Redis 와 같은 인 메모리 캐시입니다.

AWS 는 관리형 AmazonElastiCache서비스의 일부로 두 기술을 모두 제공합니다.

AmazonElastiCache 는 클라우드에서 인 메모리 데이터 스토어 또는 캐시를 손쉽게 배포,운영 및 조정할 수 있는 웹 서비스입니다.

이 서비스는 디스크 기반 데이터베이스에 전적으로 의존하기보다는,빠른 관리형 인 메모리 캐시에서 

정보를 검색할 수 있는 기능을 지원해 웹 애플리케이션의 성능을 향상합니다.

애플리케이션 서버와 데이터베이스 사이에 캐시를 배치하는 것은 데이터베이스에서 읽기 로드를 줄이는 일반적인 메커니즘이며,

따라서 더 많은 쓰기를 지원하는데 리소스를 사용할 수 있습니다.  또한,캐시는 지연 시간을 개선할 수 있습니다.

관계형 데이터베이스는 정형 데이터와 비즈니스 객체를 저장하는 데 여전히 많이 사용됩니다.

AWS 는 AmazonRelationalDatabaseService(RDS)를 통해 관리형 서비스로 6 개의 데이터베이스 엔진(MicrosoftSQLServer,Oracle,MySQL,
MariaDB,PostgreSQL및 AmazonAurora)을 제공합니다.

AmazonRDS 를 사용하면 클라우드에서 관계형 데이터베이스를 손쉽게 설치,운영 및 확장할 수 있습니다.

시간 소모적인 데이터베이스 관리 작업을 관리하는 한편,비용 효율적이고 크기 조정이 가능한 용량을 제공하므로 고객은 애플리케이션과 비즈니스에 좀 더 집중할 수 있습니다.

그러나 관계형 데이터베이스는 무한한 확장이 가능하도록 설계되지 않았으므로,

대량의 쿼리를 지원하도록 기술을 적용하는 작업은 매우 어렵고 시간이 오래 걸릴 수 있습니다.

NoSQL데이터베이스는 관계형 데이터베이스의 일관성보다 확장성,성능 및 가용성을 높이도록 설계되었습니다.

한 가지 중요한 요소는 NoSQL데이터베이스가 일반적으로 엄격한 스키마를 적용하지 않는다는 것입니다.

데이터는 수평으로 확장할 수 있는 파티션에 분산되며 파티션 키를 통해 검색됩니다.

개별 마이크로서비스는 한 가지 작업을 잘 수행하도록 설계되었으므로 일반적으로 NoSQL지속성에 적합한 단순화된 데이터 모델을 사용합니다.

NoSQL데이터베이스는 관계형 데이터베이스와 액세스 패턴이 다르다는 것을 이해하는 것이 중요합니다.

예를 들어,테이블 조인을 수행할 수 없습니다.테이블 조인이 필요한 경우,애플리케이션에 해당 로직을 구현해야 합니다.

```
AmazonDynamoDB 는 어떤 규모에서든 지연 시간이 일관되게 10 밀리초 미만이어야 하는 모든 애플리케이션을 위한,빠르고 유연한 NoSQL 데이터베이스 서비스입니다.
```

AmazonDynamoDB 를 사용하여 대용량 데이터를 저장 및 검색하고 원하는 수준의 요청 트래픽을 지원할 수 있는 데이터베이스 테이블을 생성할 수 있습니다.

DynamoDB 는 일관되고 빠른 성능을 유지하면서 고객이 지정한 요청 용량과 저장된 데이터 양을 처리할 수 있도록 충분한 수의 서버로 테이블의 데이터와 트래픽을
자동으로 분산합니다.

DynamoDB 는 원하는 규모와 성능을 제공하도록 설계되었습니다.  대부분의 경우 DynamoDB응답 시간은 10 밀리초 미만으로 측정됩니다. 

그러나 일부 사용 사례에서는 마이크로초 단위의 응답 시간이 필요합니다.

이러한 사용 사례의 경우,DynamoDB Accelerator(DAX)가 최종적 일관된 데이터에 액세스할 수 있는 캐싱 기능을 제공합니다.

개발자가 캐시 무효화,데이터 채우기 또는 클러스터를 관리할 필요가 없도록 DAX 는 DynamoDB테이블에 인 메모리 가속을 추가하는 데 필요한 모든
작업을 수행합니다.

DynamoDB 는 실제 트래픽 패턴에 대응하여 사용자 대신 프로비저닝된 처리 능력을 동적으로 조정할 수 있는 AutoScaling기능을 제공합니다.

프로비저닝된 처리량은 애플리케이션이 테이블이나 인덱스에서 사용할 수 있는 최대 용량입니다.

워크로드가 감소하면 애플리케이션 AutoScaling 이 처리량을 줄이므로 사용되지 않은 프로비저닝된 용량에 대해 비용을 지불할 필요가 없습니다.

---

ㅁ 운영상의 복잡성 감소

앞에서 설명한 아키텍처에서는 다양한 관리형 서비스를 사용하고 있지만,일부 고객은 여전히 EC2인스턴스를 운영하기도 합니다.

AWS 에서는 완전한 서버리스(Serverless) 아키텍처를 사용하여 마이크로서비스를 실행,유지 관리 및 모니터링하는 데 필요한 운영 작업을 더욱 줄일 수 있습니다.

- API구현

개별 API 를 설계하고,지속적으로 개선,배포,모니터링 및 유지 관리하는 것은 시간 소모적인 작업이 될 수 있습니다.

때로는 클라이언트에 대한 모든 API 가 이전 버전과 호환되도록 보장하기 위해 여러 버전의 API 를 실행해야 합니다.

개발 주기의 다양한 단계(개발,테스트 및 프로덕션)때문에 몇 배의 운영 노력이 필요합니다.

액세스 권한 부여는 모든 API 에 매우 중요한 기능이지만,일반적으로 구축하기 복잡하고 반복적인 작업이 수반됩니다.

API 를 성공적으로 게시했으면,다음 과제는 API 를 활용하는 타사 개발자의 에코시스템을 관리,모니터링 및 수익화하는 것입니다.

다른 중요한 기능 및 과제로는 백엔드를 보호하기 위한 요청 조절,API응답 캐싱,요청 및 응답 변환,Swagger등의 도구를 사용하여 API정의 및 문서 생성 등이 있습니다.

AmazonAPIGateway 는 이러한 문제를 해결하고 RESTfulAPI 를 생성하고 유지 관리하는 운영상의 복잡성을 줄입니다.

```
AmazonAPIGateway 는 어떤 규모에서든 개발자가 API 를 손쉽게 생성,게시, 유지 관리,모니터링 및 보호할 수 있게 해주는 완전관리형 서비스입니다.
```

APIGateway 에서는 AWSAPI또는 AWSManagementConsole 을 사용하여 Swagger형식을 가져와 프로그래밍 방식으로 자동으로 API 를 생성할 수 있습니다.

APIGateway 는 AmazonEC2,AmazonECS,AWSLambda또는 모든 온프레미스 환경에서 실행되는 모든 웹 애플리케이션의 관문 역할을 합니다.

간단히 말하면 서버를 관리하지 않고도 API 를 실행할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/155920756-4996f21e-6080-453d-993a-cd6bf4bd3391.png)

그림는 APIGateway 가 어떻게 API호출을 처리하고 다른 구성 요소와 상호 작용하는지 보여줍니다.

모바일 디바이스,웹 사이트 또는 기타 백엔드 서비스의 요청은 가장 가까운 CloudFrontPoP(PointofPresence)으로 라우팅하여, 

지연 시간을 최소화하고 최적의 사용자 환경을 제공합니다.

또한,CloudFront 는 리전별 엣지 캐시를 제공합니다.

엣지 캐시는 최종 사용자와 아주 가깝게 전 세계에 배포되는 지점으로 원본 오리진 서버와 최종 사용자에게 직접 트래픽을 제공하는 글로벌 엣지 로케이션 사이에
위치합니다.

APIGateway 는 먼저 요청이 엣지 로케이션 또는 리전별 엣지 캐시 로케이션의 캐시에 있는지 확인하고,캐시된 레코드가 없는 경우 이를 처리하기 위해백엔드로 전달합니다.

이는 GET요청에만 적용되며 다른 모든 요청 방법은 자동으로 전달됩니다.

백엔드에서 요청을 처리한 후에는 API호출 지표가 AmazonCloudWatch 에 기록되고 콘텐츠가 클라이언트로 반환됩니다.

---

ㅁ 서버리스 마이크로서비스

```
AWSLambda 를 사용하면 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있습니다.
사용한 컴퓨팅 시간에 대해서만 요금을 지불하면 되고 코드가 실행되지 않을 때는 요금이 부과되지 않습니다.
Lambda 를 사용하면 사실상 모든 유형의 애플리케이션 또는 백엔드 서비스를 실행할 수 있으며 이를 관리할 필요는 전혀 없습니다.
```
![image](https://user-images.githubusercontent.com/62640332/155922519-8af18ee0-1bfa-4196-b1e8-582f30bf3e60.png)

그림 은 전체 서비스가 관리형 서비스로 구성된 서버리스 마이크로서비스 아키텍처를 보여줍니다.

이러한 아키텍처에서는 확장 및 고가용성을 설계하는 데 따른 아키텍처 관련 부담이 해소되며,마이크로서비스의 기본 인프라를 실행하고 모니터링하는 운영
작업이 사라집니다.

---

ㅁ Lambda기반 애플리케이션 배포
AWSCloudFormation 을 사용하여 서버리스 애플리케이션을 지정,배포 및 구성할 수 있습니다.

```
CloudFormation 은 AWS리소스를 모델링하고 설정하는 데 도움이 되는 서비스로,
이를 통해 이러한 리소스를 관리하는 데 드는 시간을 줄이고 AWS 에서 실행되는 애플리케이션에 좀 더 집중할 수 있습니다.
```


AWSServerlessApplicationModel(AWSSAM)은 서버리스 애플리케이션을 정의하는 가장 편리한 방법입니다.

AWSSAM 은 CloudFormation 에서 기본적으로 지원되며 서버리스 리소스를 표현하기 위한 단순화된 구문을 정의합니다.

애플리케이션을 배포하려면 CloudFormation템플릿에서 관련 권한 정책과 함께 애플리케이션의 일부로서 필요한 리소스를 지정하고,

배포 아티팩트를 패키징한 후, 템플릿을 배포하기만 하면 됩니다

---

ㅁ 서비스 검색

- 클라이언트측서비스검색
  
서로 다른 계층 또는 서비스를 연결하는 가장 간단한 방법은 대상의 IP주소를 통신 소스 구성의 일부로 하드코딩하는 것입니다.

이를 DomainNameSystem(DNS)또는 애플리케이션 구성에 저장하면,시스템이 서로 통신해야 할 때마다 활용할 수 있습니다.

당연히 이 해결책은 애플리케이션이 확장될 때 제대로 작동하지 않습니다.대상 속성이 본질적으로 동적이기 대문에 이 방법은 마이크로서비스 아키텍처에 권장되지 않습니다.

대상 시스템이 속성(IP주소든 포트 정보든 상관없이)을 변경할 때마다 소스 시스템이 구성을 업데이트해야 합니다

<br>
<br>


- ApplicationLoadBalancer기반서비스검색
  
ApplicationLoadBalancing 의 장점 중 하나는 장애 발생 시 백엔드 서비스의 상태 확인 및 자동 등록/등록 취소를 제공하는 것입니다.

ApplicationLoadBalancer 에서는 경로 기반 및 호스트 기반 라우팅 접근 방식도 제공합니다.

이러한 기능을 DNS기능과 결합하면 최소한의 노력과 저렴한 비용으로 간단한 서비스 검색 솔루션을 구축할 수 있습니다.

마이크로서비스에 대한 사용자 지정 도메인 이름을 구성하고 CNAME항목을 사용하여 해당 도메인 이름을 ApplicationLoadBalancer 의 DNS이름과 연결할 수
있습니다.

그러면 서비스 엔드포인트의 DNS이름이 액세스가 필요한 다른 애플리케이션에 게시됩니다

![image](https://user-images.githubusercontent.com/62640332/155923331-57e6ab29-f99a-4a0f-892c-ced04d412a35.png)


<br>
<br>

- DNS기반서비스검색


AmazonRoute53 은 서비스 검색 정보를 저장하는 또 다른 소스가 될 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/155923442-06577523-0f88-4c6a-9504-a60976aebc3a.png)


```
Route53 은 가용성과 확장성이 뛰어난 클라우드 DNS웹 서비스입니다.
```

Route53 은 서비스 검색에 활용할 수 있는 몇 가지 기능을 제공합니다.

프라이빗 호스팅 영역 기능을 사용하면 도메인 또는 하위 도메인에 대한 DNS레코드 세트를 저장하고 특정 VirtualPrivateCloud(VPC)에 대한 액세스를 제한할 수 있습니다.

특정 마이크로서비스에 대한 IP주소,호스트 이름 및 포트 정보를 서비스 레코드(SRV레코드)로 등록하고 관련 클라이언트 마이크로서비스의 VPC 에 대한 액세스를 제한할
수 있습니다.

또한,애플리케이션 상태를 정기적으로 확인하고 리소스 레코드 간에 장애 조치를 잠재적으로 트리거하는 상태 확인을 구성할 수도 있습니다.


<br>
<br>

- AmazonECS이벤트스트림을사용한서비스검색

Route53기반 서비스 검색을 구현하는 다른 접근 방식은 AmazonECS이벤트 스트림 기능을 활용하는 것입니다

![image](https://user-images.githubusercontent.com/62640332/155923553-a5734fe6-ffe4-45a8-b9b8-7a1b623357fb.png)

AmazonECS이벤트 스트림을 CloudWatch이벤트에 사용하면 AmazonECS 클러스터 내 컨테이너 인스턴스의 현재 상태와 해당 컨테이너 인스턴스에서 실행 중인
모든 작업의 현재 상태에 대해 거의 실시간 알림을 받을 수 있습니다.

CloudWatch 규칙을 사용하여 ECS클러스터 내의 특정 변경 사항(예:시작,중지)을 필터링하고 해당 정보를 사용하여 Route53 의 DNS항목을 업데이트할 수 있습니다.


<br>
<br>

- 구성관리를사용한서비스검색

서비스 검색을 구현하는 또 다른 방법은 구성 관리 도구(예:Chef,Puppet,Ansible)를 사용하는 것입니다.

EC2인스턴스에서 실행되는 에이전트는 서버를 시작하는 동안 구성 정보를 등록할 수 있습니다.

이 정보를 다른 구성 관리 정보와 함께 호스트 또는 중앙 집중식 스토어에 저장할 수 있습니다.

구성 관리 도구를 사용할 때의 어려움 중 하나는 상태 확인 정보를 업데이트하는 빈도입니다.

애플리케이션의 상태를 검색하고 업데이트를 즉시 전파하여 부실한 상태 정보를 방지하려면 클라이언트 구성을 철저히 수행해야 합니다.

그림 은 구성 관리 시스템인 AWSOpsWorks 를 사용한 서비스 검색 메커니즘을 보여줍니다.

![image](https://user-images.githubusercontent.com/62640332/155923641-1dc43939-1ff6-4e79-8a6c-96bea8146989.png)


<br>
<br>

- 키값스토어를사용한서비스검색
  
키 ­ 값 스토어를 사용하여 마이크로서비스를 검색할 수도 있습니다.

이 접근 방식은구축하는 데 다른 접근 방식보다 시간이 더 오래 걸리지만,더 뛰어난 유연성과 확장성을 제공하며 DNS캐싱 문제가 발생하지 않습니다.

또한,NetflixRibbon 과 같은 클라이언트 측 로드 밸런싱 기법과도 원활하게 연동됩니다.

클라이언트 측 로드밸런싱은 병목 현상을 제거하고 관리를 간소화하는 데 도움이 될 수 있습니다.

그림은 AmazonDynamoDB 를 키-값 스토어로 활용하고 AmazonDynamoDB Streams38를 사용하여 상태 변경을 다른 마이크로서비스로 전파하는 아키텍처를
보여줍니다

![image](https://user-images.githubusercontent.com/62640332/155923736-4d21e5c2-e83f-43e5-88b1-06a9f9f95dac.png)


---


ㅁ 분산 데이터 관리

일반적으로 대규모 관계형 데이터베이스에서 모놀리식 애플리케이션을 지원하여 모든 애플리케이션 구성 요소에 공통적으로 적용되는 단일 데이터 모델을 정의하게 됩니다.

마이크로서비스 접근 방식에서 이러한 중앙 데이터베이스는 분산되고 독립적인 구성 요소를 구축하는 목표에 방해가 됩니다.

각 마이크로서비스 구성 요소에는 고유한 데이터 지속성 계층이 있어야 합니다. 

하지만 분산 데이터 관리로 인해 새로운 문제가 발생합니다. CAP이론에서 설명하는 것처럼,

분산 마이크로서비스 아키텍처는 본질적으로 성능을 위해 일관성을 절충하며 최종적 일관성을 수용해야 합니다.

마스터 데이터 관리 도구 및 절차로 큐레이트되는 중요 참조 데이터의 중앙 집중식 스토어를 구축하면 마이크로서비스에서 중요 데이터를 동기화하고 상태를 롤백할 수
있습니다.

AWSLambda 를 예약된 AmazonCloudWatchEvents 와 함께 사용하면 간단한 정리 및 중복 제거 메커니즘을 구축할 수 있습니다.

상태 변경이 둘 이상의 마이크로서비스에 영향을 미치는 것은 매우 일반적입니다.이러한 경우,이벤트 소싱(EventSourcing)이 유용한 패턴인 것으로 입증되었습니다.

이벤트 소싱의 핵심 아이디어는 모든 애플리케이션 변경을 이벤트 레코드로 표시하고 유지하는 것입니다. 

애플리케이션 상태를 유지하는 대신 데이터가 이벤트 스트림으로 저장됩니다.

데이터베이스 트랜잭션 로깅과 버전 제어 시스템은 이벤트 소싱의 두 가지 잘 알려진 예입니다.

이벤트 소싱에는 몇 가지 이점이 있습니다.즉,어느 시점에서든 상태를 확인하고 재구성할 수 있습니다.

이렇게 하면 자연스럽게 지속적인 감사 트레일이 생성되고 디버깅도 용이해집니다.

마이크로서비스 아키텍처에서 이벤트 소싱은 게시/구독(Pub/Sub) 패턴을 사용하여 애플리케이션의 여러 부분을 분리할 수 있으며,

동일한 이벤트 데이터를 별도의 마이크로서비스를 위한 서로 다른 데이터 모델에 공급합니다.

쓰기 워크로드에서 읽기를 분리하고 성능,확장성 및 보안에 맞게 두 워크로드를 모두 최적화하기 위해 이벤트 소싱과

CQRS(Command,Query,Responsibility,Segrated)패턴은 자주 함께 사용됩니다.

기존의 데이터 관리 시스템에서는 명령과 쿼리가 동일한 데이터 리포지토리에 대해 실행됩니다.

그림 13 은 AWS 에서 이벤트 소싱 패턴을 구현하는 방법을 보여줍니다.

Amazon KinesisStreams 는 애플리케이션 변경 사항을 이벤트로 캡처하여 AmazonS3 에 유지하는 중앙 이벤트 스토어의 주요 구성 요소의 역할을 합니다.

```
KinesisStreams 를 사용하면 특수한 요구 사항에 맞춰 스트리밍 데이터를 처리하거나 분석하는 사용자 지정 애플리케이션을 구축할 수 있습니다.

KinesisStreams 는 웹 사이트 클릭스트림,금융 트랜잭션,소셜 미디어 피드,IT 로그 및 위치 추적 이벤트와 같은 수십만 개 소스에서 시간당 테라바이트 규모의
데이터를 지속적으로 캡처하고 저장할 수 있습니다
```

그림 13 은 AmazonAPIGateway,AmazonEC2및 AmazonDynamoDB 로 구성된 세 가지 서로 다른 마이크로서비스를 보여줍니다.

파란색 화살표는 이벤트의 흐름을 나타냅니다. 마이크로서비스 1 이 이벤트 상태 변경을 경험하면 메시지를 작성하여 KinesisStreams 에 이벤트를 게시합니다.

모든 마이크로서비스는 메시지 복사본을 읽고 마이크로서비스의 관련성을 기준으로 이를 필터링한 다음 추가 처리를 위해 전달할 수 있는 자체 KinesisStreams애플리케이션을 EC2인스턴스 플릿(Fleet)에서 실행합니다.

![image](https://user-images.githubusercontent.com/62640332/155924083-f6ea61bf-4814-410d-879b-e5e87284edd4.png)

AmazonS3 는 모든 마이크로서비스에 걸쳐 모든 이벤트를 안전하게 저장하며,디버깅, 애플리케이션 상태 복구 또는 애플리케이션 변경 감사를 수행할 때 신뢰할 수 있는
중요한 스토리지입니다.

---

ㅁ 비동기식 통신 및 간단한 메시징

기존의 모놀리식 애플리케이션 통신은 매우 간단합니다.애플리케이션의 일부가 메서드 호출 또는 내부 이벤트 배포 메커니즘을 사용하여 다른 부분과 통신할 수 있습니다.

서로 분리된 마이크로서비스를 사용하여 동일한 애플리케이션을 구현하는 경우, 애플리케이션의 서로 다른 부분 간 통신은 네트워크 통신을 사용하여 구현해야 합니다.

<br>
<br>

- REST기반통신

HTTP/S프로토콜이 마이크로서비스 간에 동기식 통신을 구현하는 가장 보편적인 방법입니다.

대부분의 경우 RESTfulAPI 는 HTTP 를 전송 계층으로 사용합니다.

REST 아키텍처 스타일은 상태 비저장 통신,단일 인터페이스 및 표준 메서드를 사용합니다.

APIGateway 를 사용하면 '관문’의 역할을 하는 API 를 생성할 수 있습니다.

개별 애플리케이션은 이 API 를 통해 AmazonEC2및 AmazonECS 에서 실행되는 워크로드,Lambda 에서 실행되는 서버리스 코드,웹 애플리케이션과 같은 백엔드
서비스의 데이터,비즈니스 로직 또는 기능에 액세스할 수 있습니다.

APIGateway 서비스를 사용해 정의한 API객체는 리소스 및 메서드 그룹입니다.

리소스는 API도메인 내에 유형이 지정된 객체이며,데이터 모델과 연결되어 있거나 다른 리소스와 관계가 있을 수 있습니다.

하나 이상의 메서드,즉 GET,POST또는 PUT 과 같은 표준 HTTP 동사에 응답하도록 각 리소스를 구성할 수 있습니다.

RESTAPI 는 각기 다른 단계에 배포하고,버전을 지정하고,새로운 버전으로 복제할 수 있습니다.

APIGateway 는 트래픽 관리,권한 부여 및 액세스 제어,모니터링,API버전 관리 등 최대 수십만 개 동시 API호출의 수신 및 처리와 관련된 모든 작업을 처리합니다.

<br>
<br>

- 비동기식메시징

메시지 전달은 마이크로서비스 간의 통신을 구현하기 위한 추가적인 패턴입니다.

개별 서비스는 대기열을 통해 메시지를 교환하는 방식으로 통신합니다.

이러한 통신 방식의 주요 이점 중 하나는 서비스 검색 기능이 필요 없다는 것입니다.

AmazonSimple QueueService(AmazonSQS)및 AmazonSimpleNotificationService(SNS)를 사용하면 이 패턴을 간단하게 구현할 수 있습니다.

```
AmazonSQS 는 클라우드 애플리케이션의 구성 요소를 비용 효율적으로 간단하게 분리하기 위해 사용할 수 있는 빠르고 안정적이며 확장 가능한
완전관리형 대기열 서비스입니다.

AmazonSNS 는 완전관리형 알림 서비스로,개발자가 애플리케이션에서 메시지를 게시하고 구독자 또는 다른 애플리케이션에 즉시 전달할 수 있도록
고도로 확장 가능하고 유연하며 비용 효율적인 기능을 제공합니다
```

두 서비스 모두 긴밀하게 연동됩니다.

AmazonSNS 를 사용하면 애플리케이션에서 푸시 메커니즘을 통해 다수의 구독자에게 메시지를 전송할 수 있습니다.

Amazon SNS 와 AmazonSQS 를 함께 사용하면 하나의 메시지를 다수의 소비자에게 전송할 수 있습니다.

그림 14 는 AmazonSNS 와 AmazonSQS 의 통합을 보여줍니다.

![image](https://user-images.githubusercontent.com/62640332/155924532-3000510e-a83a-423c-bb6f-183f8dc4c94a.png)

특정 SNS주제에 대한 SQS대기열을 구독하면,메시지를 해당 주제에 게시할 수 있으며 AmazonSNS 는 구독된 SQS대기열로 메시지를 전송합니다.

메시지에는 JSON형식의 메타데이터 정보와 함께 주제에 게시된 제목 및 메시지가 들어있습니다.

<br>
<br>

- 서비스오케스트레이션및상태관리

마이크로서비스의 분산 특성으로 인해 여러 마이크로서비스가 얽혀 있는 워크플로를 오케스트레이션하기가 어렵습니다.

개발자는 서비스에 오케스트레이션 코드를 직접 추가하고 싶은 경우가 있습니다.

하지만 그렇게 하면 매뉴얼 작업으로 인해 개별 서비스를 신속하게 교체하기가 더 어려워지므로 이는 피해야 합니다.

```
AWSStepFunctions 를 사용하면 시각적 워크플로를 사용해 분산 애플리케이션 및 마이크로서비스의 구성 요소를 손쉽게 조정할 수 있습니다.
```

StepFunctions 를 사용하여 각각이 개별 기능을 수행하는 개별 구성 요소로 애플리케이션을 빌드할 수 있습니다.

StepFunctions 는 오류 처리,서비스 직렬화/병렬 실행과 같은 서비스 오케스트레이션의 복잡성을 숨기는 상태 구성 시스템을 제공합니다.

따라서 서비스 내에 추가적인 조정 코드를 사용하지 않고 애플리케이션을 신속하게 확장 및 변경할 수 있습니다.

StepFunctions 는 구성 요소를 조정하고 애플리케이션의 기능을 단계별로 실행하는 신뢰할 수 있는 방법입니다.

StepFunctions 에서는 애플리케이션의 구성 요소를 일련의 단계로 배열하고 시각화할 수 있는 그래픽 콘솔을 제공합니다.

그러므로 손쉽게 분산 서비스를 구축하고 실행할 수 있습니다.

StepFunctions 가 자동으로 각 단계를 트리거 및 추적하고 오류가 발생할 경우 재시도하므로 애플리케이션이 의도대로 정상적으로 실행됩니다.

StepFunctions 는 각 단계의 상태를 기록합니다.따라서 무언가 잘못된 경우 빠르게 문제를 진단하고 디버깅할 수 있습니다.

코드를 작성하지 않고 단계를 변경 및 추가할 수 있어 애플리케이션을 개선하고 더 빠르게 혁신할 수 있습니다.

StepFunctions 는 AWS서버리스 플랫폼의 일부로,AmazonEC2및 Amazon ECS 와 같은 컴퓨팅 리소스를 기반으로 하는 애플리케이션뿐만 아니라 Lambda함수의 오케스트레이션을 지원합니다.

그림 15 는 Lambda함수의 호출은 Step Functions 에서 AWSLambda 로 직접 푸시되는 반면,

AmazonEC2또는 Amazon ECS 의 작업자는 호출을 계속해서 폴링하는 것을 보여줍니다. 

StepFunctions 는 어떤 규모에서든 애플리케이션을 사용할 수 있도록 운영 및 기본 인프라를 관리합니다.

![image](https://user-images.githubusercontent.com/62640332/155924746-fc6954d6-16d1-4221-ad55-f7aa146301d4.png)

StepFunctions 는 워크플로를 작성하기 위해 AmazonStatesLanguage(ASL)를 사용합니다.

워크플로에는 순차적 또는 병렬 단계뿐만 아니라 분기 단계도 포함될 수 있습니다.

그림 16 은 순차적 단계와 병렬 단계가 조합된 마이크로서비스 아키텍처 워크플로의 예를 보여줍니다.

이러한 워크플로는 StepFunctionsAPI또는 APIGateway 를 통해 호출할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/155924794-22122a79-d5e7-40b9-93af-5fa1c32c88c9.png)

---

ㅁ 분산 모니터링
마이크로서비스 아키텍처는 모니터링해야 하는 다양한 분산 부분으로 구성되어 있습니다.

```
CloudWatch 는 AWS클라우드 리소스 및 AWS 에서 실행하는 애플리케이션을 모니터링하는 서비스입니다.
```

CloudWatch 를 사용하여 지표를 수집 및 추적하고,로그 파일을 중앙 집중화 및 모니터링하며,경보를 설정하고,AWS환경의 변경 사항에 자동으로 대응할 수 있습니다.

CloudWatch 는 EC2인스턴스,DynamoDB테이블,RDSDB인스턴스 같은 AWS리소스는 물론 애플리케이션과 서비스에서 생성된 사용자 지정 지표와 애플리케이션에서 생성된 모든 로그 파일을 모니터링할 수 있습니다.

<br>
<br>

- 모니터링
CloudWatch 를 사용하여 시스템 전반의 리소스 사용률,애플리케이션 성능,운영 상태를 파악할 수 있습니다.

CloudWatch 는 몇 분 안에 시작할 수 있는 안정적이고 확장 가능하며 유연한 모니터링 솔루션을 제공합니다.

더 이상 자체 모니터링 시스템 및 인프라를 설정,관리 및 확장할 필요가 없습니다.

마이크로서비스 아키텍처에서는 CloudWatch 를 사용하여 사용자 지정 지표를 모니터링하는 기능이 추가적인 이점을 제공하는데,

이는 개발자가 각 서비스에 대해 수집해야 하는 지표를 결정할 수 있기 때문입니다.

이외에도,사용자 지정 지표를 기반으로 동적 확장을 구현할 수 있습니다.


<br>
<br>

- 로그중앙집중화
  
일관된 로그 저장은 문제를 해결하고 식별하는 데 매우 중요합니다.

마이크로서비스를 통해 팀은 이전보다 많은 기능을 출시할 수 있으며,엔지니어링 팀은 프로덕션에서 새로운 기능을 실험할 수 있습니다.

점진적으로 애플리케이션을 개선하기 위해서는 고객 영향을 이해하는 것은 매우 중요합니다.

대부분의 AWS서비스는 로그 파일을 중앙 집중적으로 저장합니다.

AWS 에서 로그파일을 저장하는 주요 대상은 AmazonS3 와 AmazonCloudWatchLogs 입니다.

EC2인스턴스에서 실행되는 애플리케이션의 경우 데몬을 사용하여 로그 파일을 CloudWatchLogs 로 전송할 수 있습니다.

Lambda함수는 기본적으로 로그 출력을 CloudWatchLogs 로 전달하며,AmazonECS 는 컨테이너 로그를 CloudWatch Logs 로 중앙 집중화할 수 있는 awslog 로그 드라이버를 지원합니다.

그림 17 은 일부 서비스의 로깅 확장 방법을 보여줍니다.

그러면 개발팀은 Amazon ElasticsearchService(ES)및 Kibana 와 같은 도구를 사용하여 이러한 로그를 검색하고 분석할 수 있습니다.

AmazonAthena 는 AmazonS3 의 중앙 집중식 로그 파일에 대해 임의 쿼리를 실행하는 데 사용할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/155927827-82e4c80e-ecfe-4c45-a531-b6022aa22400.png)


- 분산추적

 대부분의 경우,개별 마이크로서비스가 함께 연동하여 요청을 처리합니다.
 
수십 개의마이크로서비스로 구성된 복잡한 시스템이 있고 호출 체인의 서비스 중 하나에서 오류가 발생하는 상황을 상상해보십시오.

모든 마이크로서비스가 제대로 로깅되고 있고 로그가 중앙 시스템에 통합되더라도,모든 관련 로그 메시지를 찾는 것은 매우 어려울 수 있습니다.

```
AWSX-Ray 는 요청이 애플리케이션을 통과할 때 요청에 대한 엔드 투 엔드
뷰를 제공하고 애플리케이션 기본 구성 요소의 맵을 보여줍니다.
```

X-Ray 의 핵심 아이디어는 상관관계 ID 를 사용하여 문제를 추적하는 것입니다.

이 ID 는 특정 이벤트 체인과 관련된 모든 요청과 메시지에 첨부되는 고유한 식별자입니다.

추적 ID 는 요청이 첫 번째 X-Ray통합 서비스(예:ApplicationLoadBalancer또는 API Gateway)에 도달하고 응답에 포함될 때 X-Amzn-Trace-Id 라는 특정 추적 헤더의
HTTP요청에 추가됩니다.

모든 마이크로서비스는 X-RaySDK 를 통해 이 헤더를 읽을수 있을 뿐만 아니라 추가하거나 업데이트할 수도 있습니다.

AWSX-Ray 는 AmazonEC2,AmazonECS,AWSLambda및 AWSElastic Beanstalk 와 연동됩니다.

이러한 서비스에 배포되었으며 Java,Node.js및 .NET 으로 작성된 애플리케이션에서 X-Ray 를 사용할 수 있습니다.

- AWS 의로그분석옵션

로그 데이터의 검색,분석 및 시각화는 분산 시스템을 이해하는 데 있어 중요한 요소입니다.

로그 파일을 분석하는 데 널리 사용되는 옵션 중 하나는 Amazon ElasticsearchService(ES)를 Kibana 와 함께 사용하는 것입니다.


```
AmazonES 를 사용하면 로그 분석,애플리케이션 모니터링,대화식 검색 등을 위해 Elasticsearch 를 쉽게 배포,운영 및 확장할 수 있습니다.
```

AmazonES 는 전체 텍스트 검색,구조화된 검색,분석 및 이 세 가지의 조합에 사용할 수 있습니다.

Kibana 는 AmazonES 용 오픈 소스 데이터 시각화 플러그인으로 AmazonES 와 원활하게 통합됩니다.

그림 19 는 AmazonES및 Kibana 를 사용한 로그 분석을 보여줍니다.

CloudWatch Logs구독을 통해 거의 실시간으로 로그 항목을 AmazonES 로 스트리밍하도록 CloudWatchLogs 를 구성할 수 있습니다.

Kibana 는 데이터를 시각화하고 Amazon ES 의 데이터 스토어에 편리한 검색 인터페이스를 제공합니다.

이 솔루션을 ElastAlert 등의 소프트웨어와 함께 사용하면,데이터에서 이상 항목,스파이크 또는 기타 관심 패턴이 감지될 경우 SNS알림과 이메일을 보내고 JIRA티켓을 생성하기 위한 경고 시스템을 구현할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/155928072-c7470b82-090f-4c03-a7cc-2364d74de124.png)

로그 파일을 분석하는 또 다른 옵션은 AmazonRedshift 를 AmazonQuickSight 와 함께 사용하는 것입니다.

```
AmazonRedshift 는 속도가 빠른 페타바이트 규모의 완전관리형 데이터 웨어하우스로,기존의 비즈니스 인텔리전스 도구를 사용하여 모든 데이터를 비용
효율적으로 간편하게 분석할 수 있습니다.

AmazonQuickSight 는 데이터를 사용하여 시각화를 구축하고,임시 분석을 수행하며,비즈니스 통찰력을 신속하게 확보할 수 있는 클라우드 기반의 빠른
비즈니스 분석 서비스입니다.
```

AmazonQuickSight 는 AmazonRedshift,AmazonRDS,AmazonAurora, AmazonEMR,AmazonDynamoDB,AmazonS3및 AmazonKinesis 를 비롯한
AWS데이터 서비스에 쉽게 연결할 수 있습니다.

AmazonCloudWatchLogs 는 로그 데이터의 중앙 집중식 스토어 역할을 할 수 있으며,데이터를 저장하는 것 외에도 로그 항목을 AmazonKinesisFirehose 로
스트리밍할 수 있습니다.

```
KinesisFirehose 는 AmazonS3,AmazonRedshift또는 AmazonES 와 같은 대상에 실시간 스트리밍 데이터를 제공하기 위한 완벽관리형서비스입니다.
```

그림 20 은 CloudWatchLogs및 KinesisFirehose 를 사용하여 로그 항목을 여러 소스에서 AmazonRedshift 로 스트리밍하는 시나리오를 보여줍니다.

Amazon QuickSight 는 분석,보고 및 시각화를 위해 AmazonRedshift 에 저장된 데이터를 사용합니다.

![image](https://user-images.githubusercontent.com/62640332/155928295-497063a5-44a5-4c31-9061-8114865695ef.png)

그림 21 은 AmazonS3 의 로그 분석 시나리오를 보여줍니다.

로그가 S3버킷에 저장되면 로그 데이터를 다른 AWS데이터 서비스(예:AmazonRedshift또는 AmazonEMR)에 로드하여 로그 스트림에 저장된 데이터를 분석하고 이상 항목을 찾을
수 있습니다.

