- CI/CD : 개발자가 코드 변경사항을 중앙 repository에 정기적으로 벙합하고, 빌드와 테스트 과정을 거쳐 프러덕션에 릴리스하는 각 과저을 포함한다.
- IaC: 버전 제어, 지속적 통합과 같은 코드 및 소프트웨어 개발 기법을 사용하여 인프라를 프로비저닝하고 관리

![image](https://user-images.githubusercontent.com/62640332/155364530-06abcc20-8a38-4274-a025-9ca8028b445a.png)



애플리케이션을 관리한다는 것은 로직을 구성하는 코드 뿐만아니라 해당 애플리케이션 인프라 관리도 포함한다.

이는 AWS위에 웹 애플리케이션을 구축했다고 가정한다면, VPC, EC2, RDS등도 관리해야한다는것이 된다.

![image](https://user-images.githubusercontent.com/62640332/155365137-ee2bad50-f1c1-4b8c-8c8b-769f9cd0b93f.png)

초보자는 GUI 방식이 좋지만, 자동화 하기위해서는 CLI 방식으로 해야한다.

 CLI 명령어 똑같이 재현 어려움, SDK 자원의 자동생성을 지원하고 벌크형태로 만드는게 가능하지만, aws에 대한 엑세스 용도로만 사용되는경우가 대부분

 그래서 AWS  CloudFomration 이나 AWS Cloud Development Kit(AWS CDK)로 만드는게 devops의 모범사례에 적합하다.

 


 대부분 devops팀이 겪는 3R problem
 
 - repeatability(반복성)
 - reproducibility(재현성)
 - reliability(신뢰성)

사람들이 같은 반복적으로 같은 환경 만들시 휴먼에러로 가끔 다른 결과 나오는 경우가 있다. 또 개발환경에서는 문제가 없었지만 프러덕션 환경에서는 문제 발생하는 경우가 있다.

이러한 인프라 관리에서 발생할수 있는 문제를 IaC 관리를 통해 아예 제외시킬수 있다.

IaC는 소스코드처럼 버전닝 및 관리가 되어, 환경내에 일어나는 일 추적이 가능하다. 즉 변경기록과 롤백이 비교적 쉽다.

또한 동일한 config 파일, 코드만 있다면 여러개의 환경을 만들어 낼수 있다.

AWS 에서 IaC 방식 : AWS CloudFormation, AWS CDK
Third-pary tool : HashiCorp Terraform, puppet

![image](https://user-images.githubusercontent.com/62640332/155366962-ed6c89dd-d684-4b10-8bbc-db8c28e132a0.png)

앱 코드, 인프라 템플릿 작성후 배포하고, 실제환경에서 사용하고 다시 최적화를 위해 반복


![image](https://user-images.githubusercontent.com/62640332/155367166-a0532aeb-e247-47bb-89f2-2df1b6eff307.png)

AWS resource를 모델링하고 설정하여 리소스 관리에 대한 신경을 경감시키고, 해당 리소스위에 애플리케이션에 집중할수 있게하는 서비스

아마존 EC2, RDS 관련값을 기재한 템플릿을 생성하면 클라우드 포메이션이 해당 리소스에 프로비저닝과 구성을 담당한다.

클라우드 포메이션을 사용하면 aws 리소스를 사용자가 개별적으로 생성하고 구성할 필요가 없으며, 관련된 dependency에 대해 파악할 필요가 없어진다.

![image](https://user-images.githubusercontent.com/62640332/155367900-879e7a51-7d96-4b27-935b-dc795ba6406a.png)

![image](https://user-images.githubusercontent.com/62640332/155367949-05e92a3a-8b5f-4db8-bc21-e799b2c8332e.png)

코드는 템플릿이라는 파일에 기록이 되고, 스택은 탬플릿을 통해 발생된다.

탬플릿은 주로 애플리케이션을 위한 리소스를 정의합니다. 리소스의 상태를 설명

각 리소스는 사용가능한 속성에 따라 구성되고, 종속석을 명시적으로 선언하거나 암묵적으로 검색 가능하다.

클라우드 포메이션은 이러한 의도를 API 호출로 변환하여 리소스를 프로비저닝 한다.

위의 예시는 Yalm 

- 버전은 선택사항 
- 설명은 상세히 적는것 중요
- 파라미터는 해당 탬플릿 사용하는 사용자에게 하는 질문
- 매핑은 스스로 채워지는 파라미터와 같다. ex) 매핑마다 리전마다 구동할 AIM을 명시해 놓으면 서울 리전 안에서 새로운 탬플릿 만들때 실행할 AIM을 자동적으로 선택된다.
- 조건의경우 참인경우에만 리소스 생성
- 리소스는 탬플릿에서 유일하게 필수로 작성해야하고, 생성할 aws 리소르를 기재하는 부분
- 아웃풋은 리소스가 프로비저닝된 후에도 도출될수 있는 값

![image](https://user-images.githubusercontent.com/62640332/155369312-a21a1a43-31da-4332-a2c0-09b4c5df9e15.png)

![image](https://user-images.githubusercontent.com/62640332/155369769-f6dc5735-d9da-4447-9648-7cab30c8b1e5.png)

![image](https://user-images.githubusercontent.com/62640332/155369871-0d763734-b57b-4792-be21-ae3aa4fbdb07.png)

![image](https://user-images.githubusercontent.com/62640332/155369990-f010aad0-9fd8-4391-86a7-2e225a1297ad.png)

이미 aws 해비 사용자라면 , 여러개의 개정을 가지고, 하나의 개정에서 여러개의 리전 사용할것이다. 이떄 aws cloud formation을 어떻게 확장해서 사용할수 있을까?

=> Stack set

statck set 들을 위한 stack을 생성 가능하다. 스택셋 만든후에는 언제든지 추가 계정 및 리전에 대한 스택을 추가 가능하다.



탬플릿을 생성후 바로 클라우드 포메이션에 업로드는 가능하지만, 해당  탬플릿이 에러가 발생한다면 리소스가 프로비저닝이 불가능해진다.

로직 단에서의 에러는 탬플릿 작성전에 완료 되어야한다. ==> 오픈소스 툴인 cfn-lint 

해당 툴 사용하면 탬플릿 배포전에 에러를 인지하고 수정이 가능해진다.

![image](https://user-images.githubusercontent.com/62640332/155370837-e0326487-1ab7-4e2a-b791-5768b721e7b8.png)


처음 소규모의 리소스 프로비저닝에는 하나의 플랫폼에 관련 정보를 모두 명시하는것이 효율적이지만, 워크로드의 범위가 커지면

계층화된 아키텍처 방식으로 만들어야 한다. 

생김새가 비슷하여 cloud formation cake 라고도 불린다. 성격이 비슷하고, 리소스의 라이프 사이클 비슷한것 끼리 묶어서 사용해야 한다.

![image](https://user-images.githubusercontent.com/62640332/155371098-19e7e379-84ed-4423-a59a-8e7593abb4ed.png)

예를 들어 네트워크 보안시 애플리케이션 바이너리 파일 및 데이터베이스 변경시 함께 변경될 가능성 적음

이렇게 각각 분리하면 실수로 자원 삭제 막을수 있고, 필요한 부분만 업데이트 가능하여 이후 리소스 테스트 및 트러블 슈팅 용이 해진다.

IaC 이상적인 가정은 리소스 관련 작업은 IaC를 통해서 하는것이다. 그러나 급하게 일부 변경사항 있을경우 수동으로 리소스 컨트롤 한다.

이와같이 관리되지 않는 변경은 실행중인 스택의 구성이 템플릿에서 드리프트 되었기 때문에 기존에 의도한 상황과 실제 리소스 상태가 불일치 하게 된다.

==> 드리프트 감지기 사용 한다. 

![image](https://user-images.githubusercontent.com/62640332/155371624-bd31a8bd-50e1-46d1-ab69-6cd7a424e94b.png)


db의 패스워드와 같이 중요정보는 하드코딩하지 않는다. 이와같이 빨간글씨 처럼 aws 시스템 매니저 파라미터 스토어에 저장하고 불러오는것 중요

![image](https://user-images.githubusercontent.com/62640332/155371822-f02b0e2b-0c5f-41c2-b2f8-43cbf2ae343c.png)

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155372016-4f2fb894-7283-48ee-8496-199c7fb340d8.png)

![image](https://user-images.githubusercontent.com/62640332/155372086-5a23c594-4a74-438b-aa71-982b7a6976b5.png)

- core framework를 이용하여 하나이상의 stack 포함된 앱을 만들고 구성 가능

stack은 여러 리소스를 포함하고, one to one 클라우드 포메이션 스택과 맵핑된 단위를 의미

- AWS Construct Library는 aws에서 특정 서비스에 대한 리소스를 생성하기 위해 만들어진 구성요소의 집합으로, 프로젝트에 필요한 dependency만 사용할수 있다.

또한, 사용편의성 및 빠른 반복주기에 적합하도록 모범 사례를 기반으로 만들어져 있다.

- AWS CDK CLI는 core framework와 상호작용하며, 프로젝트에 스트럭쳐를 초기화하고 배포된 상태와 배포할 상태의 차이점을 비교하여, aws 환경에 쉽게 리소스 반영할수 있도록 지원합니다.

![image](https://user-images.githubusercontent.com/62640332/155372817-96c2c14b-518b-4166-ba55-a842eca4fce5.png)

aws cdk 는 해당 소스코드를 컴파일하여 어셈블리 언어 형태인 클라우드 포메이션 템플릿을 만들고

이를 클라우드 포메이션 스택에 배포하여 안전하고 반복가능한 형식으로 클라우드 리소스를 프로비저닝 합니다.

사용자는 첫번째로 CDK init 명령어 시작하고 그와 동시에 cdk는 특정 프로그래밍언어에 대한 프로젝트 구조를 생성

사용자는 앱을 만들고, 스택, 컨스트럭트, 리소스를 추가할수 있다.

그와 관련된 작업이 완료되면 프로젝트를 빌드 합니다. 예를 들어 타입스크립트를 사용한다면 npm run 명령어 사용

그리고 사용자는 작성한 코드를 클라우드 포메이션 탬플릿으로 컴파일 해야한다.

이떄 cdk synth를 사용하면 탬플릿과 에셋이 생성된다. 

마지막으로, cdk deploy를 통해 클라우드 포메이션이 적용되면,   aws 계정에 리소스 프로비저닝 된다.

이후 소스코드를 수정하고 반영시 빌드 및 디플로이를 반복하되, 기존의 프로비저닝된 리소스와의 변경사항을

체크하기 위해 디플로이 이전 cdk diff 명령어 사용한다. 

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155470656-7442145f-39dc-45a7-9c02-050d0604e3e5.png)



왼쪽은 CDK 오른쪽 클라우드 포메이션으로 작성한것.

CDK는 프로그래밍 언어의 모든 기능을 활용하여 aws 인프라를 코드로 정의하는 개발자 중심의 도구 키트

클라우드 포메이션을 활용하여, 안전한 배포, 자동 롤백, 드리프트 감지 등 클라우드 포메이션 이점을 계속 이용가능하다.

실제 애플 vs 애플 비교한다면 클라우드 포메이션으로 리소스에 대한 코드를 작성할때보다 CDK로 작성할때

더 적은 코드로 같은 결과 도출 가능하다. 그러나 프로래밍 언어 기술이 필요하기 때문에, 기술이 없다면 러닝커브 

발생할수 있다. ==> 사용자에게 적합한 툴 사용하면 된다.

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155470896-aa9e8c05-adf3-46ec-9b15-ae2902a62b37.png)

지속적 통합/배포의 레이아웃 입니다.

개발자가 소스코드를 repository에 push 하면, 일련의 과정을 거쳐  프러덕션 환경에 반영됩니다.

이러한 모든 프로세스 자동화 하는것이 devops의 목적


![image](https://user-images.githubusercontent.com/62640332/155471098-4499ce4b-e832-422f-bb00-85647f8ed75f.png)



![image](https://user-images.githubusercontent.com/62640332/155471320-4d5c3f01-4166-4620-b121-007e7ffec415.png)



처음 개발 코드를 작성하는 환경부터 aws 가능합니다.

aws cloud9을 사용하면,  웹브라우저에서 코드를 작성하고 실행하고 디버깅 가능하다.

클라우드 9은 클라우드 기반 IDE로 프로그래밍 언어로, 필수 언어가 패키징 되있고, 웹브라우저에서 실행하기때문에

어디서든 작업을 진행할수 있다. 그리고, 개발 환경이 팀과 공유하면 코드협업 쉬워진다.

그리고 aws 위에서 개발위한 sdk, 라이브러리, 플러그인 제공한다.

또한, 터미널 창에서 aws 직접적으로 엑세스하여 컨트롤이 가능하다.

클라우드9으로 코드작성하고 작성한 코드를 저장소에 반영하면, 사전에 구축된 코드 파이프라인 동작하고

최종적으로 애플리케이션 변경되는 형태 이다. 해당 애플리케이션에 모니터링 붙여서 현제 나의 애플리케이션이

잘 작동하고있는지, 최적화할 부분 있는지 확인이 가능하다.


![image](https://user-images.githubusercontent.com/62640332/155476612-e7ffc29d-ccf1-4cf9-b0ca-7e1a46b02104.png)

CI/CD 에서 소스 빌드 테스트 디플로이를 하나의 큰 묶음으로 파이프라인으로 표현

완전 관리형 이기때문에 사용자는 인프라 관리에 대해 신경쓸 필요 없다.


![image](https://user-images.githubusercontent.com/62640332/155479624-07b36e68-bff0-4785-9e3f-063054f2bd6c.png)

- 코드 파이프라인 구축시 각 스테이지에서 선택할수 있는 옵션

- 소스 스테이징 에서는 aws codecommit, github에서 소스 변경시 파이프라인이 트리거 가능

s3에 아티팩트 들어올떄, 콘테이너 워크로드 사용시 컨테이너 이미지 변경시에도 파이프라인 트리거 가능

스케줄링 및 자원의 상태에 따라 트리거 가능

- 빌드 스테이징에서는 Jenkins 나 code build 부착 가능하며 선택사항

- 배포 스테이징에서는 EC2 인스터스, 온프레미스 서버, 람다, 아마존 ECS, fargate


![image](https://user-images.githubusercontent.com/62640332/155480269-350045ec-cbb4-4f5e-be6f-7303b444cdf0.png)

처음 소스코드 푸시 하면, 소스가 빌드되고, 최종적으로 aws 클라우드 포메이션에 변경분 반영

![image](https://user-images.githubusercontent.com/62640332/155480411-e18f96c4-c966-4c80-b170-31cb6349e95e.png)

![image](https://user-images.githubusercontent.com/62640332/155480434-1d8d7775-5a47-4e9c-aafe-c032b6e309d5.png)

개별적으로 파이프 라인 생성된다.

- CI
  
1. 새 코드가 체크인될 때 새 빌드를 자동으로 시작
2. 일관되고 반복 가능한 환경에서 코드 빌드 및 테스트
3. 배포에 사용할 아티팩트를 지속적으로 준비
4. 빌드 실패 시 피드백 루프를 최적화

<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155480650-4ed36663-738a-41f0-b862-c626c15724e6.png)


소스코드 컴파일, 유닛 테스트, 소프트웨어 패키지 생성까지 가능한 완전 관리형 빌드 서비스

빌드 볼륨에 맞춰 자동적으로 확장 가능하며, 여러 빌드를 동시에 병렬적으로 처리 가능

병렬 작업시 레이턴시 시간 줄일수 있는 이점을 가진다. 그리고, 빌드속도 향상위해 캐시기능 있음

코드 빌드를 통해 빌드 실행시 환경 정의해야 하는데, 여기서 빌드환경은 코드 빌드가 빌드 실행하기 위해 사용하는 OS, 프로그래밍 언어, 런타임, 도구의 조합 의미

AWS에서 환경 지원하지만, 사용자가 커스터마이징한 환경도 가능


![image](https://user-images.githubusercontent.com/62640332/155481259-67b21dd1-faae-4093-9381-0bc098ce77b5.png)

코드빌드를 실행위해서 빌드스팩.yaml 파일 작성해야 한다. 

빌드스팩 파일 에서  리포트 명시해논 파일 확인가능.

유닛 테스트 보고서를 만들기 위해 리포트의 결과 경로를 빌드스팩에 추가후,

코드 빌드 리포트에서  리포트 그룹 생성후, 관련 ARN 빌드 스펙에 붙여넣으면 유닛 테스트 세부사항 확인 가능

<br>
<br>

- CD

1. 테스트를 위해, 스테이징 환경에 새로운 변경 사항 자동 배포
2. 고객의 사용성에 영향을 미치지 않고 안전하게 프로덕션 환경으로 배포(실제 프로덕션 환경에서 제로다운 패치도 중요)
3. 고객에게 신속하게 제공: 배포 빈도를 높이고, 변경 리드 타임 및 변경 실패율 감소


일반적으로 빌드까지가 CI 영역,

CD의 경우 스테이징 환경까지가서 로컬 테스트를 넘어 다른 시스템과의 통합테스트, 부합테스트 등을 통해 최종적으로 프로덕션 아티팩트 만드는 과정

변경분을 에자일하게 반영하고, 변경실패율 감소하는것이 지속적 배포의 목표 => CodeDeploy

<br>
<br>
<br>

![image](https://user-images.githubusercontent.com/62640332/155482140-2cb818dd-37b4-4fc3-9a17-546ad4f888df.png)


테스트환경, 스테이징환경, 프로덕션 환경에 있는 실제 인스턴스에 아티팩트 배포한다.

복잡한 업데이트를 간편하게 핸들링 가능, 배포중 다운타임을 최소화 가능하며, 여러 애러발생시 자동 롤백기능 지원

마지막은 배포 대상으로, 온프레미스의 경우 agent 설치하여 code deploy가 통신해서 진행한다.




![image](https://user-images.githubusercontent.com/62640332/155482687-fb7dd283-21e6-4525-a534-d02bf1bfd276.png)


codeDeploy 에도 appspec 파일 존재하며, 해당 파일 배포 진행방식 정의한다.

예를들어 파일에 정의된 일련의 수명주기 후크로 배포를 관리합니다.



![image](https://user-images.githubusercontent.com/62640332/155482807-bdaeff2a-bfd8-4beb-b49a-3ee40fed7c2d.png)


또한 배포속도 및 그룹도 조절 가능하다.

![image](https://user-images.githubusercontent.com/62640332/155482846-1547a275-60f1-459f-901b-80966bf631c9.png)

릴리즈 프로세스를 하나의 코드 파이프라인 구축의 예시 이다.

코드 변경분이 코드 커밋에 반영되고 유닛 테스트 실행한 파일이 코드 빌드를 통해 빌드가 된다.

그리고 canary 배포를통해 스테이징 환경에 코드 디플로이 되고, 로드테스트 실행후 프로덕션 환경에 배포 된다.

