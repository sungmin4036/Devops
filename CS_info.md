

객체의 life cycle

파이썬 실행했을 때 메모리와 cpu에서 일어나는 일을 질문 받았지만, 우선 class를 기준으로 설명해놓은 블로그를 찾아서 해당 내용으로 정리한다. (참고 링크)

The life cycle of an object consists of three basic steps:

- creation: 클래스를 정의하고 인스턴스를 생성한다. 이 때 객체에 메모리가 할당되고, 객체가 조작될 준비를 마치게 된다. 


- destruction: 객체의 reference count가 0이 될 때, 더이상 참조하는 값이 없을 때 객체가 삭제된다. 객체가 필요 없어졌을 때 제거하는 것을 garbage collection이라고 한다. 

[thread와 multiprocess의 차이]

프로세스: 운영체제로부터 자원을 할당받은 작업의 단위.

스레드: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.


ㅁ 프로그램 -> 프로세스 -> 스레드

- 프로그램 -> 프로세스


프로그램 이란?  
: 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태


1. 메모리에 올라가 있지 않은 의미
: 아직 os가 프로그램에게 독립적인 메모리 공간 할당 X, 모든 프로그램은 os 실행되기 전에 메모리 공간을 할당해줘야 실행 가능하다.

2. 정적인 상태
: 움직이지 않는 산태라는 뜻으로, 아직 실행되지 않고 가만히 있다는 뜻이다.

프로그램이라는 단어는 아직 실행되지 않은 파일 그자체를 가르키는 말이다.

*.exe 파일과 같은 걸로, 쉽게 말해 코드 덩어리 이다.

프로그램을 실해하면, 컴퓨터 메모리에 파일이 올라가고, 이 상태를 동적인 상태라고 하며, 이 상태의 프로그램을 ``프로세스`` 라고한다.

프로세스의 정의는 실행되고 있는 프로그램 이라고 하고 있으며, 스케줄링 단계에서의 작업과 같은 단어라고 봐도 무방하다.

실제 프로레스 단어가 작업중인 프로그램 이라는 의미의 단어이기 떄문이다.


- 프로세스 -> 스레드

과거에는 프로그램 실행시 시작부터 끝까지 프로세스 하나만 사용하여 진행하였다.


한 프로그램을 처리하기 위한 프로세스를 여러개 만들면 되지 않을까?? 했지만 불가능한 일이었다.

왜냐하면 os는 안정성을 위해서 프로세스마다 자신에게할당된 메모리 내의 정보에만 접근이 가능하도록 제약을 두고 있고, 이를벗어나는 정보에 접근하려면 오류가 발생하기 때문이다.


그래서 더 작은 실행 단위 개념이 필요하게 되었고, ``스레드``가 등장하였다.

스레드는 프로세스와 다르게 스레드간 메모리를 공유하며 작동한다.

스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 되는 것이다.

프로그램이 코드 덩어리라고 했는데, 스레드도 코드에 비유하자면, 

스레드는 코드 내에 선언된 함수들이 되고 따라서 main 함수 또한 일종의 스레드라고 볼 수 있게 된다.


스레드란?  프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로


os는 프로세스 마다 독립된 메모리 영역 code/data/stack/heap 형식으로 할당한다.

이와 다르게 스레드는 공유가 가능하며, 자세히 설명하면, 프로세스가 할당받은 메모리 영역 내에서

stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 code/data/heap 형식으로 할당된 메모리 영역을 공유한다.

따라서 각각의 스레드는 별도의 스택을 가지고 있지만, 힙 메모리는 서로 읽고 쓰기 가능핟.

만약 프로세스를 실행하다가 오류가 발생하여 프로세스가 강제종료 된다면 다른 프로세스 에게는 아무런 영향을 주지 않는다.

그런데 스레드의 경우에는 메모리 영역을 공유하기 때문에 다른 쓰레드 모두가 강제로 종료된다.


<H4>왜 이런 방색으로 메모리를 공유 하는 것인가??</H4>

CPU 입장에서의 최소 작업 단위가 스레드 이다. 

cpu는 작업을 처리할 때 스레드를 최소 단위로 삼고 작업을 하는 반면에, 

운영체제는 이렇게 작은 단위까지 직접 작업하지 않기 떄문에  운영체제 관점에서는 프로세스가 최소 작업 단위가 된다.

여기서 중요한 점은 프로세스 하나당 하나 이상의 스레드를 가진다.

따라서 운영체제 관점에서는 프로세스가 최소 작업 단위인데 이 때문에 같은 프로세스 소속의 스레드 끼리 메모리를 공유하지 않을수 없다.



<h4>멀티 태스킹, 멀티 스레드는 무엇일까??</h4>

- 멀티태스킹 란?
: 하나의 운영체제 안에서 여러 프로세스가 실행 되는 것을 의미, 여러 프로세스가 동시에 실행되는것처럼 보이지만, 아니다. 

- 멀티 스레드 란?
: 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는것을 말한다.

- 멀티 스레드 장점

1. context-switching시 공유 하고 있는 메모리 만큼의 메모리 자원 아끼기 가능.
2.  스레드는 프로세스 내의 stack 영역을 제외하고 모든 메모리를 공유 하기 때문에 통신의 부담이 적어서 응답 시간이 빠르다.

- 멀티 스레드 단점

1. 스레드 하나가 프로세스 내자원을 망쳐버린다면 모든 프로세스가 종로 될수 있따.
2. 자원을 공유하기 때문에 필연적으로 동기화 문제(synchronization Issue)가 발생할 수 밖에 없다.

\# 동기화 문제란?
: 멀티스레드를 사용하면 각각의 스레드중 어떤 것이 어떤 순서로 실행될지 순서를 알수없다.

만약 A 스레드가 어떤 자원을 사용하다가 B스레드로 제어권이 넘어간후 B르세드가 해당 자원을 수정시, 다시 제어권을 받은 A 스레드가 해당 자원에 접근하지 못하거나, 바뀐 자원에 접근되는 오류가 발생할수 있다.

이처럼 여러 스레드가 함께 전역 변수를 사용할경우 할생할수 있는충동을 ``동기화 문제`` 라고한다.


최근에는 프로세스가 다른 프로세스에 접근이 가능하지만, 자원 부담이 크다.

그 방법으로는

1. IPC(Inter-Process Communication)사용
2. LPC(Local inter-Process Communication)사용
3. 별도의 공유 메모리를 만들어서 정보를 주고 받로록 설정해주면 된다.






python은 thread보다 process를 통한 병렬처리를 더 선호한다고 한다. GIL 때문에 multiprocess로 작업하는 것이 더 빠르다.

multiprocessing을 thread 대신 사용해 multi core CPU의 장점을 사용할 수 있고, global interpreter lock 병목 현상을 피할 수 있다.






[parameter와 argument의 차이]

- parameter: 함수를 정의할 때 사용
- argument: 함수를 호출할 때 사용


- Call by value(값에 의한 호출)는 인자로 받은 값을 복사하여 처리를 한다. 

- Call by reference(참조에 의한 호출)는 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다. 
 
간단히 말해 값을 복사를 하여 처리를 하느냐, 아니면 직접 참조를 하느냐 차이인 것이다. (참고 링크)


<br>


ㅁ Call by value(값에 의한 호출)

- 장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.
- 단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.

ㅁ Call by reference(참조에 의한 호출)

- 장점 : 복사하지 않고 직접 참조를 하기에 빠르다.
- 단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.(리스크)

Python 은 명시적인 Call by Reference 혹은 Call by Value 라는 개념이 존재하지 않는다.

Python의 function에 argument 를 전달할 때, 이는 Manual 에 따르면 call by assignment 라는 방식으로 전달된다. 

이는 Parameter로 전달받는 객체에 따라 객체의 참조방식이 결정된다는 의미로, 공식 문서에 따르면 

Mutable Object 는 Call by reference의 형태로 참조형으로 변수를 다루며 Immutable Object는 Call by value 의 형태로 변수를 핸들링한다.

- Mutable Object : list, dict, set 등의 객체

- Immutable Object : str, int, tuple 등의 객체

출처: https://jins-dev.tistory.com/entry/Python-의-Call-by-assignment-의-개념 [Jins' Dev Inside]

![image](https://user-images.githubusercontent.com/62640332/149622088-4d55e22a-55af-489a-815e-e5418cf2bd44.png)

<br>

- iterable object

리스트, Set, Dictionary와 같은 컬렉션이나 문자열과 같은 문자 Sequence 등은 for 문을 써서 하나씩 데이타를 처리할 수 있는데, 이렇게 하나 하나 처리할 수 있는 컬렉션이나 Sequence 들을 Iterable 객체(Iterable Object)라 부른다.

- iterator

이터레이터는 값 생성기이다. “다음"값을 요청할 때마다 내부 상태를 유지하고 있기 때문에 다음값을 계산하는 방법을 알고있다.

- generator

Generator 함수(Generator function)는 함수 안에 yield 를 사용하여 데이타를 하나씩 리턴하는 함수이다.

Generator 함수가 처음 호출되면, 그 함수 실행 중 처음으로 만나는 yield 에서 값을 리턴한다. Generator 함수가 다시 호출되면, 직전에 실행되었던 yield 문 다음부터 다음 yield 문을 만날 때까지 문장들을 실행하게 된다. 


- GIL(Global interpreter lock)

전역 인터프리터 잠금은 컴퓨터 언어 인터프리터에서 스레드 실행을 동기화하여 한 번에 하나의 기본 스레드 만 실행할 수 있도록하는 메커니즘입니다.

GIL을 사용하는 인터프리터는 멀티 코어 프로세서에서 실행 되더라도 항상 한 번에 하나의 스레드 만 실행할 수 있습니다.

파이썬에서 쓰레드을 여러 개 생성한다고 해서 여러 개의 쓰레드가 동시에 실행되는 것은 아니다.

정확히 말하자면 두 개의 쓰레드가 동시해 실행되는 것처럼 보일 뿐, 특정 시점에서는 여러 개의 쓰레드 중 하나의 쓰레드만 실행된다.

파이썬은 멀티 쓰레딩 환경에서 각 쓰레드가 특정 객체를 사용할 경우 처리가 어려워(복잡한 이유지만 변수 관리 방법과 연관이 있음),

이러한 걱정을 할 필요가 없도록 특정 시점에서 하나의 쓰레드만 실행되도록 락을 걸어 두었다.

Global Interpreter Lock 이라는 이름이 지칭하듯이, 

파이썬 인터프리터 (Interpreter) 자체에서 락을 (Lock) 전역적으로 (Global) 설정해 둔 것이다. 

이로 인해 여러 쓰레드가 동시에 사용하는 공유 자원 동기화 문제는 자연스럽게 해결된다. C Extension으로 래핑된 라이브러리를 사용할 때도 Thread Safety를 고려할 필요가 없다고도 한다.

<br>
<br>


- sync & async

링크에 라이브러리(async.io)를 사용해 비동기처리 방식을 간단하게 정리해놓았다.

동기는 시간을 맞추는 것이다. A 함수를 호출하는데 걸리는 시간이 1초, B가 2초라 할 때 총 3초가 걸린다.

반면 비동기는 시간을 맞추지 않는 것으로, 동시에 호출되기 때문에 총 2초가 걸리게 된다.


- Blocking

Blocking은 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 것이다.

예를 들어 호출하는 함수가 IO를 요청했을 때 IO처리가 완료될 때까지 아무 일도 하지 못한 채 기다리는 것을 말한다.

- Non-Blocking

Non-Blocking은 Blocking과 반대되는 개념이다. 

직접 제어할 수 없는 대상의 작업 처리 여부와 상관이 없다.

예를 들어 호출하는 함수가 IO를 요청한 후 IO처리 완료 여부와 상관없이 바로 자신의 작업을 할 수 있다.


<br>

- 메모리

주기억장치(主記憶裝置) 또는 컴퓨터 메모리(computer memory)는 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치를 가리킨다. 이 용어는 1차 기억 장치와 동의어이다.

메모리는 RAM(Random Access Memory) 또는 ROM(Read Only Memory)처럼 일시적으로 기억을 저장할 수 있는 모든 물리 장치를 말한다.



---

<h1> 1. 프로그래밍 공통 </h1>

[ OOP란 ]
OOP는 현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물들을 객체로 보고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법입니다. 

OOP로 코드를 작성하면 재사용성과 변형가능성을 높일 수 있습니다.

 

 

[ OOP의 5가지 설계 원칙 ]

- SRP(Single Responsibility Principle, 단일 책임 원칙): 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
- OCP(Open-Closed Principle, 개방 폐쇠 원칙): 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.
- DIP(Dependency Inversion Principle, 의존 역전 법칙): 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안된다.
 

 

[ 절차지향 프로그래밍 VS 객체지향 프로그래밍 ]
 

ㅁ 절차지향 프로그래밍

- 물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다.
- 가장 대표적인 언어로 C언어가 있다.
- 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
- 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

ㅁ 객체지향 프로그래밍

- 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
- 가장 대표적인 언어로 Java가 있다.
- 캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.
- 절치지향 언어보다 실행속도가 느리다.
 

 

[ RESTful API ]

REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 차원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다. 

RESTful API는 아래와 같은 것들로 구성됩니다.

 

- Resource(자원, URI)
- Method(요청 방식, GET or POST 등)
- Representation of Resource(자원의 형태, JSON or XML 등)
 

[ 함수형 프로그래밍 ]

함수평 프로그래밍의 가장 큰 특징은 immutable data와 first class citizen으로서의 함수입니다.

함수형 프로그래밍은 부수효과가 없는 순수 함수를 이용하여 프로그램을 만드는 것이다.

부수 효과가 없는 순수 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미합니다.

 

 

[ 메모리 구조 ]


![image](https://user-images.githubusercontent.com/62640332/149622125-1a04dd83-2612-4b6d-8581-8e1e3e3864b4.png)

- 코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부릅니다.
 
 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됩니다.

<br>

- 데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역입니다.

데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

<br>

- 힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부릅니다. 
 
 Java에서는 가비지 컬렉터가 자동으로 해제해줍니다.
 
 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됩니다.

<br>

- 스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역입니다.

 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 합니다. 스택 영역은 함수의 호출이 완료되면 소멸합니다. 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됩니다.
 

 

[ Parameter와 Argument의 차이 ]
 

- Parameter: 함수를 선언할 때 사용된 변수

- Argument: 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값
 

 

[ Call By Value와 Call By Reference 차이 ]
 

ㅁ Call By Value

- 인자로 받은 값을 복사하여 처리하는 방식
- Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존된다.
- 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어난다.

<br>

ㅁ Call By Reference

- 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
- 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
- 원래의 값에 영향을 주는 리스크가 존재한다.
 

예를 들어 아래와 같은 코드가 있다고 할 때, a라는 새로운 변수가 생성되어 Call By Value로 전달되기 때문에 메모리를 많이 사용하지만 a를 변경하여도 원래 값인 f는 영향을 받지 않습니다.

```
public class Main {
     public static void main(String[] args) { 
         Foo f = new Foo("f");
          changeReference(f); // It won't change the reference! modifyReference(f); // It will modify the object that the reference variable "f" refers to! 
          }

        public static void changeReference(Foo a) {
             Foo b = new Foo("b"); a = b;
              } 
              
        public static void modifyReference(Foo c) { 
            c.setAttribute("c"); 
            } 
        }
```

![image](https://user-images.githubusercontent.com/62640332/149622158-51437743-1d5b-42c8-ade6-93cf790a8d07.png)


[ 프레임워크와 라이브러리 차이 ]
 

- 라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다.
  
- 프레임워크: 전체적인 흐름을 자체적으로 제어한다.

프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다.

프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됩니다.

 

 

[ 병렬 처리 프레임워크의 종류와 특징 ]
 

ㅁ Hadoop

- HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받는다.
- 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있다.
- 하지만 File I/O를 기반으로 작동하기 때문에 처리 속도가 느리다.

ㅁ Spark

- In-Memory 상 에서 데이터를 주고받고 연산을 수행한다.
- 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠르다.
- 하지만 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 한다.
 

 

[ 동기와 비동기의 차이 ]
 

ㅁ 동기(Synchronous) 방식

- 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
- 순서에 맞추어 진행되기 때문에 제어하기 쉽다.
- 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다.
- 동기 방식의 예시로는 콜센터 종업원이 일을 처리하는 방식이 될 수 있다. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행할 수 있다.

ㅁ 비동기(Asynchronous) 방식

- 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
- 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있다.
- 작업이 완료된 결과를 제어하기 어렵다.
- 비동기 방식의 예제로는 이메일이 있다. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보낼 수 있다. 
 

[ SQL Injection ]

SQL Injection이란 공격자가 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL을 실행하도록 하는 웹해킹기법입니다.

예를 들어 아래와 같은 간단한 SQL 문이 있을 때 INPUT1에 'OR 1=1--을 넣는 것입니다.

```
SELECT * FROM USER WHERE ID = 'INPUT1' AND PASSWORD = 'INPUT2' SELECT * FROM USER WHERE ID = '' OR 1=1 --INPUT1' AND PASSWORD = 'INPUT2'
```
<br>

1. 프로그래밍 공통 - 고급

[ 메세지 큐(Message Queue)란? ]

메세지 큐(Message Queue)란 Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템으로,

비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해준다. 

메세지 큐에서는 Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리하게 된다.

메세지 큐에는 Kafka, Rabbit MQ, AMPQ 등이 있다.

 

[ Docker(도커)와 Kubernates(쿠버네티스) ]

Docker는 컨테이너 기반의 가상화 기술입니다.

기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 했습니다. 하지만 이러한 방식은 상당히 무겁고 느려 한계가 많이 있었습니다.

그래서 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장하게 되었고, 

도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장하게 되었습니다.

 

 

[ Docker(도커)의 장/단점 ]

- 장점
  
    - 쉽고 빠른 실행 환경 구축
    - 하드웨어 자원 절감
    - Docker Hub와 같은 공유 환경 제공


- 단점

    - 개발 초기의 오버헤드
    - Linux 친화적
 
 <br>

[ TDD(Test-Driven Development) ]

TDD(Test-Driven Development)는 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로,

개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 의미합니다.

개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 하기 때문에 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힙니다.

 

<br> 

[ DDD(Domain-Driven Design) ]

DDD(Domain-Driven Design)는 실세계에서 사건이 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법입니다.

옷 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있습니다.

이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다.

도메인 주도 설계에서 도메인은 각각 분리되어 있는데,

이러한 관점에서 MSA(MicroService Architecture)를 적용하면 용이한 설계를 할 수 있다. 

DDD에서는 같은 객체들이 존재할 수 있는데, 

예를 들어 옷 구매자의 입장에서는 (name, price)와 같은 객체 정보를 담지만, 판매자의 입장에서는(madeTie, size, madeCountry) 등이 있을 수 있습니다. 

즉, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD입니다.

![image](https://user-images.githubusercontent.com/62640332/149622176-2d551786-b724-4ba3-b4c8-90f72ddc6ad0.png)



[ MSA란? ]

MSA(Microservice Architecture)는 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다.

MSA는 1개의 시스템을 독리접으로 배포가능한 각각의 서비스로 분할합니다.

각각의 서비스는 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성합니다.


![image](https://user-images.githubusercontent.com/62640332/149622181-9d8df6db-29ae-4acc-b01b-9f918970777d.png)

장점

- 일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않는다.
- 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
- 서비스의 확장이 용이하다.

단점

- 서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어렵다.
- 서비스 간에 RESTful API로 통신하기 때문에 그에 대한 비용이 발생한다.
- 서비스간의 호출이 연속적이기 때문에 디버깅이 어렵다.

<br>
<br>

<h1>2. 자료구조</h1>

[ 자료구조와 알고리즘 ]

자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고, 

알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임입니다.

 

 

[ 스택, 큐, 트리, 힙 구조 설명 ]

- 스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조이다.
  
- 큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다.

- 트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합하다.

- 힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리이다.


![image](https://user-images.githubusercontent.com/62640332/149622209-bfc82f8d-dc06-41fd-bdc9-d7f486ffde26.png)

[ 우선순위 큐와 내부 구조 및 시간복잡도 ]

우선순위큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 

우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다.

 

 

[ 해시 테이블와 해시 테이블의 시간 복잡도 ]

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다.

해시 테이블은 Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.

![image](https://user-images.githubusercontent.com/62640332/149622223-17f218b9-10c9-4bfb-9775-8960cf2a0989.png)


해시 테이블은 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다.

하지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가할 수 있습니다.

 

 

[ LinkedList와 ArrayList 차이 ]

ArrayList는 데이터들이 순서대로 늘어선 배열의 형식을 취하고 있지만, 

LinkedList는 자료의 주소값으로 서로 연결된 형식을 가지고 있습니다. 이러한 구조에 의해 둘은 각각의 장단점을 가지고 있습니다.

 

ㅁ ArrayList

- 원하는 데이터에 무작위로 접근할 수 있다.   
- 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.   
- 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸린다.    


ㅁ LinkedList

- 리스트의 크기에 영향 없이 데이터를 추가할 수 있다.   
- 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.   
- 무작위 접근이 불가능하며, 순차 접근만이 가능하다.   

![image](https://user-images.githubusercontent.com/62640332/149622246-36a83238-5c4b-4f94-a451-ea6b3a9338f4.png)


[ 큐와 스택의 구현 ]

- 큐(Queue): Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하다. 하지만 List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋다.
  
- 스택(Stack): List로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 Array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, Array로 구현하는 것이 좋다.

[ AVL 트리 ]

AVL 트리란 한 쪽으로 값이 치우치는 이진 균형 트리(Balanced Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리입니다. 

AVL은 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행합니다.

 

 

[ 레드블랙 트리 ]

레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠합니다. 그리고 연결된 노드들은 색이 중복되지 않도록 관리됩니다.

<br>
<br>

<h1>3. 알고리즘</h1>

[ 버블소트, 힙소트, 머지소트, 퀵소트, 삽입소트 ]

- 버블소트는 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 시간복잡도는 O(n2) 입니다.


![image](https://user-images.githubusercontent.com/62640332/149622257-b5e62107-df11-4a2e-ab9c-147ffc6134c2.png)

- 힙소트는 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘입니다.
 
  힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우입니다. 시간복잡도는 O(nlog2n) 입니다.


<br>

![image](https://user-images.githubusercontent.com/62640332/149622268-194614a7-6b62-4326-b4ce-cc7adebdc52f.png)




<br>


- 머지소트는 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘입니다. 시간복잡도는 O(nlog2n) 입니다.

![image](https://user-images.githubusercontent.com/62640332/149622295-f43f2dfc-b30e-4868-9b18-c81661e99149.png)

- 퀵소트는 매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할합니다. 
 
피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬을 합니다. 시간복잡도는 O(nlog2n) 이며 리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도가 O(n2) 까지 나빠질 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622391-344a0e63-82de-4d95-9738-590db2bdeae6.png)


- 삽입정렬은 두 번째 값부터 시작하여 그 앞에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다.

삽입 정렬의 평균 시간복잡도는 O(n2) 이며, 가장 빠른 경우 O(n) 까지 높아질 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622406-71336668-fad4-44e5-b7fd-f9e980bb83e5.png)

<br>


![image](https://user-images.githubusercontent.com/62640332/149622414-3e871e2e-fca4-4662-8e40-d4e06e2cff7b.png)


[ 동적 프로그래밍(Dynamic Programming)이란? ]

동적 프로그래밍(Dynamic Programming) 이란 주어진 문제를 풀기 위해서, 

문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식입니다.

동적 프로그래밍에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 

답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상 시킬 수 있습니다. 

 

 

[ 동적 프로그래밍(Dynamic Programming)의 두 가지 조건 ]

동적 프로그래밍(Dynamic Programming)으로 문제를 해결하기 위해서는 주어진 문제가 다음의 조건을 만족해야 한다.

 

- Overlapping Subproblem(중복되는 부분문제): 주어진 문제는 같은 부분 문제가 여러번 재사용된다.
- Optimal Substructure(최적 부분구조): 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다.
 

 

[ 재귀 알고리즘과 재귀의 시간 복잡도 ]

재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘입니다.

재귀 알고리즘은 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요합니다.

팩토리얼을 계산하는 재귀 함수에서는 T(n) = T(n-1) + c (C는 n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 아래와 같이 O(n)이 됨을 보일 수 있습니다.

```
T(n) = T(n-1) + c
 = T(n-2) + 2c = T(n-3) + 3c
  = …… 
  = T(2) + (n-2)c 
  = T(1) + (n-1)c ≤ c + (n-1)c 
  = c + cn - c 
  = cn --> O(n)

```
<br>

[ 팩토리얼의 재귀/반복문 손코딩 ]

```
private static int recursiveFactorial(int num) { 
    if(num > 1){ 
        return recursiveFactorial(num - 1) * num; 
     } 
     return 1;
}
private static int loopFactorial(int num) {
     int answer = 1;
      for (int i = 2;
       i <= num; i++) {
            answer *= i; 
            }
     return answer; }

```

[ 피보나치 수열 재귀/반복문 손코딩 ]

```
private static int recursiveFibonacci(int index) { 
    if (index <= 2){
         return 1;
          } 
          return recursiveFibonacci(index - 1) + recursiveFibonacci(index - 2); 
          } 
private static int loopFibonacci(int index) { 
    int answer = 1;
    int before = 1;
    int temp; for (int i = 2; i < index; i++) {
        temp = answer;
        answer += before;
        before = temp;
        }
        return answer; 
    }
```


1. 알고리즘 - 고급

[ n개의 배열에서 k(k<=n) 번째로 큰수를 찾는 알고리즘 ]

이러한 문제를 해결하기 위해 일반적으로 퀵정렬을 사용합니다.

하지만 퀵정렬을 사용하면 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 됩니다.

퀵선택 알고리즘은 퀵정렬을 한 후에 피봇과 K를 비교하여 아래와 같이 수행합니다.

- pivot의 인덱스가 k와 같은 경우 : 그대로 그 인덱스의 값을 리턴하면 된다.
- pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스+1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다.
- pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스-1까지 다시 Partition함수에 넘겨준다.

퀵정렬 알고리즘과의 다른 점은 예를 들어 Pivot의 인덱스가 7이고 K가 5인 경우에, 피봇의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행하는 것입니다.

이러한 이유로 퀵선택 알고리즘의 시간복잡도는 n+n/2+4/n+....1=O(n) 입니다.


![image](https://user-images.githubusercontent.com/62640332/149622579-579b43de-6d17-43ee-9d63-2c11966c4f51.png)


[ 허프만 코딩이란 ]

허프만 코딩은 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여합니다. 허프만 코드는 접두부 코드와 최적 코드를 사용합니다.

- 접두부 코드: 문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드   
- 최적코드: 인코딩된 메세지의 길이가 가장 짧은 코드   

![image](https://user-images.githubusercontent.com/62640332/149622589-ebef4c85-3d84-460e-b9ab-362874104afc.png)


[ 특정 수 이하의 3과 5의 배수의 합 구하기 손코딩 ]

```
private static int addMultipleOf3And5(int maxNum) {
    int div = maxNum / 3;
    int sum3 = (1 + div) * div * 3 / 2 ;
    div = maxNum / 5;
    int sum5 = (1 + div) * div * 5 / 2 ; div = maxNum / 15;
    int sum15 = (1 + div) * div * 15 / 2 ;
    return sum3 + sum5 - sum15;
    }
```

<h1>4. 네트워크</h1>

[ 웹 동작 방식 ]

![image](https://user-images.githubusercontent.com/62640332/149622626-ffc809bf-1ad9-45b3-99b3-53f28149b88a.png)


- 사용자가 브라우저에 URL을 입력
- 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
- HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함
- TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨
- 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함
- TCP/IP 연결을 통해 요청한 컴퓨터로 전송
- 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨


[ TCP와 UDP 차이 ]

- TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정합니다.

그렇기 때문에 높은 신뢰성을 보장하지만 속도가 비교적 느리다는 단점이 있습니다. 

- UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있습니다.

하지만 수신 여부를 확인하지 않기 때문에 속도가 빠릅니다.

TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.


![image](https://user-images.githubusercontent.com/62640332/149622638-0b6ab9ea-c022-44fc-a7cb-5187ddc75f40.png)

[ GET과 POST 차이 ]

- GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다.

URL에 데이터가 노출되기 때문에 보안적으로 중요한 데이터를 포함해서는 안됩니다.

- POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다.

완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET보다는 안전합니다.


![image](https://user-images.githubusercontent.com/62640332/149622649-6106b759-1eb4-450c-bd41-8a9b1af0a30c.png)

[ 공인 IP와 사설 IP 차이 ]
 

- 공인 IP

  - 전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소
  
  - 외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능하다.
  
  - 그에 따라 방화벽 등과 같은 보안 설정을 해주어야 한다.


- 사설 IP

   - 어떤 네트워크 안에서 사용되는 IP주소
  
   - IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소이다.
  
   - 별도의 설정 없이는 외부에서 접근이 불가능하다.
 

 

[ 웹 접근성의 국제표준 ]

웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미합니다. 

웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정하였습니다.


![image](https://user-images.githubusercontent.com/62640332/149622657-4442c454-22c5-4ec0-a755-6514d12ee09c.png)

- 7 계층(응용 계층): 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층   
- 6 계층(표현 계층): 데이터의 형식(Format)을 정의하는 계층   
- 5 계층(세션 계층): 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층   
- 4 계층(전송 계층): 최종 수신 프로세스로 데이터의 전송을 담당하는 계층   
- 3 계층(네트워크 계층): 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층   
- 2 계층(데이터링크 계층): 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층   
- 1 계층(물리 계층): 데이터를 전기 신호로 바꾸어주는 계층   


[ HTTP 프로토콜이란? ]

HTTP(Hyper Text Transfer Protocal)이란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다.

HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동합니다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성됩니다.


![image](https://user-images.githubusercontent.com/62640332/149622679-fc381ca4-0750-49df-a63e-b57cb13a31c3.png)


[ HTTP vs HTTPS ]

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 

이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. 

HTTPS는 자신의 공개키를 갖는 인증서를 발급하여 보내는 메세지를 공개키로 암호화하도록 하고 있습니다. 

공개키로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 기업을 제외한 누구도 원본 데이터를 얻을 수 없습니다.


![image](https://user-images.githubusercontent.com/62640332/149622692-e775cafc-8493-4ae5-b51e-583e03590728.png)


[ 3 Way-Handshake ]

3 Way-Handshake란 TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다.

송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태임을 확인합니다.


![image](https://user-images.githubusercontent.com/62640332/149622705-b5e0f61b-02a1-4f3c-8b28-c0d734d7e689.png)

[ HTTP 1 vs HTTP 2 ]

HTTP1은 기본적으로 연결당 하나의 요청/응답을 처리하여 다음과 같은 문제를 가지고 있었습니다.

- HOL(Head Of Line) Blocking (특정 응답 지연): 클라이언트의 요청과 서버의 응답이 동기화되어 지연 발생
- RTT(Round Trip TIme) 증가 (양방향 지연): 패킷 왕복 시간의 지연 발생
- 헤더 크기의 비대: 쿠키 등과 같은 메타데이터에 의해 헤더가 비대해짐
 

그리고 HTTP2는 다음과 같은 기술을 사용하여 HTTP1의 성능 문제를 해결하였습니다.

- Multiplexed Streams: 하나의 커넥션으로 여러 개의 메세지를 동시에 주고 받을 수 있음
- Stream Prioritization: 요청온 리소스간의 의존관계를 설정하여 먼저 응답해야하는 리소스를 우선적으로 반환함
- Header Compression: 헤더 정보를 HPACK 압축 방식을 이용하여 압축 전송함
- Server Push: HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있음


![image](https://user-images.githubusercontent.com/62640332/149622716-0a8dd6aa-d01d-426a-9555-e52ecb500a61.png)


<h1>5. 운영체제</h1>

[ Byte Ordering이란 ]   

: Byte Ordering이란 데이터가 저장되는 순서를 의미합니다. Byte Ordering의 방식에는 빅엔디안(Big Endian)과 리틀엔디안(Little Endian)이 있습니다.

- Big Endian
    - MSB가 가장 낮은 주소에 위치하는 저장 방식   
    - 네트워크에서 데이터를 전송할 때 주로 사용됨   
    - 가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.   


- Little Endian
    - MSB가 가장 높은 주소에 위치하는 방식   
    - 마이크로프로세서에서 주로 사용된다.   
    - 가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산을 할 수 있다.    

![image](https://user-images.githubusercontent.com/62640332/149622781-bb37d957-69d6-40e0-b5c9-4b3a4e4c2f2b.png)

[ 메모리란 ]

메모리는 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간입니다. 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리됩니다.

 

 

[ 프로세스와 쓰레드의 차이 ]
 

ㅁ 프로세스

- 정의: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

- 특징
    - 운영체제로부터 독립된 메모리 영역을 할당받는다. (다른 프로세스의 자원에 접근 X)
  
    - 프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.

    - 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.
 
ㅁ쓰레드

- 정의: 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위

- 특징
  
    - 쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다. (Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.)

    - 쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.
     
    - 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.

![image](https://user-images.githubusercontent.com/62640332/149622796-85a5d525-7b3d-4c3e-ae00-6763332e47ad.png)


[ 컨텍스트 스위칭(Context Switching)이란? ]

Context Switching이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다. 

Context Switching는 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 

다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다.

여기서 인터럽트란 CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 말합니다.

![image](https://user-images.githubusercontent.com/62640332/149622884-afd43165-66c0-4c2f-a165-95b36f0c8d8a.png)


[ 멀티 프로세스 VS 멀티 쓰레드 ]
 

- 멀티 프로세스   

: 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것

  - 특징

    - 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행된다.

    - Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다.

    - 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다.


- 멀티 쓰레드   

: 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것

   - 특징

      - 프로세스를 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있다.

      - 쓰레드는 메모리를 공유하기 때문에, 통신이 쉽고 자원을 효율적으로 사용할 수 있다.

      - 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받는다.

      - 여러 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있다.
 

[ 데드락(DeadLock) 이란? ]   

데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다. 

예를 들어 다음과 같은 상황에서 데드락이 발생할 수 있습니다.

자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됩니다.

 

[ 멀티 쓰레드 프로그래밍 작성 시 유의점 ]   

멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의해야 합니다.

 

[ 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 ]   

뮤텍스는 Locking 메커니즘으로 락을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제할 수 있습니다.

하지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 

세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.

 


[ CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법 ]   

이러한 문제를 해결하기 위해 메모리를 계층화하여 병목현상을 해결하고 있습니다. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있습니다.


1. 운영체제 - 고급

[ 가상메모리와 페이지폴트 ]

![image](https://user-images.githubusercontent.com/62640332/149622946-5a6d1c48-9d57-4880-be07-c099c6c47a7d.png)


가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. 

OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. 

CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다(Valid bit를 통해 확인). 

이것을 페이지 폴트라고 하는데 프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다.

 가상메모리는 하드디스크에 저장되어 있기 때문에,
 
 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.

 

 

[ 페이지 교체 알고리즘과 LRU(Least Recently Used) ]

LRU(Least Recently Used)는 페이지를 교체하기 위한 알고리즘 중 하나입니다.

페이지를 교체하는 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문입니다.

페이지 교체를 위해서는 실제메모리에 존재하는 페이지를 가상메모리로 저장한 후에, 

가상메모리에서 조회한 페이지를 실제메모리로 로드해야 됩니다.

그렇다면 어떤 실제메모리의 페이지를 가상메모리로 희생시킬 것이냐에 대한 문제가 발생하는데,

이때 사용하는 알고리즘 중 하나가 LRU(Least Recently Used) 알고리즘 입니다.

LRU 알고리즘은 실제메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식입니다. 

그 외에도 먼저 적재된 페이지를 희생시키는 FIFO(First In First Out) 알고리즘이나 LRU 알고리즘을 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 있습니다.


[ 인덱스(index)란? ]

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 

만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다.

그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데,

데이터베이스의 index는 책의 색인과 같다.

데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

만약 Index를 적용하지 않은 컬럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행된다. 

Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

 

 

[ 인덱스의 자료구조 ]

ㅁ 해시 테이블

- 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
  
- 시간복잡도가 O(1)이라 검색이 매우 빠르다.
  
- 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.

ㅁ B+Tree

- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. 
  
- BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
  
- 해시 테이블보다 나쁜 O(log2n) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.
 

 

[ DB 정규화 ]

- 제1정규형: 모든 속성 값이 원자 값을 갖도록 분해한다.

- 제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.

(여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미한다.)

- 제3정규형: 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.

(여기서 이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A,B와 B,C로 분해하는 것이 제3정규형이다.)

- BCNF 정규형: 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.
 

[ 트랜잭션(Transaction)이란? ]

하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다.

 

 

[ 트랜잭션의 ACID란? ]

- 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.

- 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.

- 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.

- 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
 

[ 이상 현상의 종류 ]

- 삭제 이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
  
- 삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
  
- 수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상
 

[ DB 락의 종류 ]

DB 락은 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구이다.

- 공유락(LS, Shared Lock): 트랜잭션이 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음

- 베타락(LX, Exclusive Lock): 트랜잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음
 

[ RDBMS와 NoSQL 차이 ]

ㅁ RDBMS

2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스 

- 장점: 스키마에 맞추어 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.

- 단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.

ㅁ NoSQL   

: RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스

- 장점: NOSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리할 수 있다.

- 단점: 중복된 데이터가 추가 가능하여, 이에 대한 관리가 필요하다.
 

 

1. 데이터베이스 - 고급

[ 힌트(Hint)란? ]

힌트란 SQL을 튜닝하기 위한 지시구문입니다.

옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우에 개발자가 직접 최적의 실행 계획을 제공하는 것입니다. 

힌트는 아래와 같이 SELECT 다음에 작성할 수 있으며, INDEX, PARALLEL 등 다양한 힌트절이 있습니다.


```
# 사용가능한 힌트절: PARALLE, INDEX, FULL ...
 SELECT /*+ [힌트절] */
```

[ 클러스터링 vs 리플리케이션 ]

ㅁ 리플리케이션   

: 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.

비동기 방식으로 노드들 간의 데이터를 동기화한다.

- 장점: 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없다.

- 단점: 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있다.

ㅁ 클러스터링   

: 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식이다.

동기 방식으로 노드들 간의 데이터를 동기화한다.

- 장점: 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영할 수 있다.

- 단점: 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replciation에 비해 쓰기 성능이 떨어진다.
 

[ 데이터베이스 튜닝과 방법 ]

DB 튜닝은 테이터베이스의 구조나 데이터베이스 자체, 운영체제 등을 조정하여 데이터베이스 시스템의 성능을 향상시키는 작업을 의미합니다. 

튜닝은 DB 설계 튜닝 -> DBMS 튜닝 > SQL 튜닝의 단계로 진행할 수 있습니다.

![image](https://user-images.githubusercontent.com/62640332/149622972-5a8f3a01-4434-4c3c-9cfc-2b42e0d6b8b4.png)



ㅁ 커널의 기능    

1. 메모리 관리: 메모리가 어디에서 무엇을 저장하는 데 얼마나 사용되는지를 추적합니다.           
2. 프로세스 관리: 어느 프로세스가 중앙 처리 장치(CPU)를 언제 얼마나 오랫동안 사용할지를 결정합니다.              
3. 장치 드라이버: 하드웨어와 프로세스 사이에서 중재자/인터프리터의 역할을 수행합니다.                           
4. 시스템 호출 및 보안: 프로세스의 서비스 요청을 수신합니다.               


올바르게 구현된 커널은 사용자가 볼 수 없으며 커널 공간이라는 자신만의 작은 작업 공간에서 메모리를 할당하고 저장되는 모든 항목을 추적


사용자 공간: 웹 브라우저 및  파일 과 같이 사용자가 볼 수 있는 것

애플리케이션은 시스템 호출 인터페이스(SCI)를 통해 커널과 통신


시스템에서 실행되는 코드는 커널 모드 또는 사용자 모드라는 두 가지 모드 중 하나로 CPU에서 실행


커널 모드에서 실행 중인 코드는 하드웨어에 무제한 액세스가 가능한 반면, 사용자 모드에서는 CPU 및 메모리가 SCI를 통해 액세스하는 것을 제한


프로세스가 사용자 모드에서 실패할 경우 손상이 제한적이며 커널에 의해 복구될 수 있음을 의미합니다. 그러나 커널 프로세스는 메모리와 프로세서에 액세스할 수 있기 때문에 충돌이 발생하면 시스템 전체가 중지될 수 있습니다. 안전 장치가 마련되어 있고 경계를 넘기 위해서는 권한이 필요하기 때문에, 사용자 프로세스 충돌은 일반적으로 커다란 문제를 유발하지는 않습니다


Linux 컨테이너는 실행에 필요한 모든 파일을 포함하여 전체 런타임 환경에서 애플리케이션을 패키지화하고 분리하는 기술
-> 전체 기능을 유지하면서 컨테이너화된 애플리케이션을 환경(개발, 테스트, 생산 등) 간에 쉽게 이동가능


Linux 컨테이너를 활용하면 담당 영역을 분리하여 개발팀과 운영팀 간의 충돌을 줄일 수 있습니다.    
개발자는 애플리케이션에 집중할 수 있고 운영팀은 인프라에 주력할 수 있습니다. 

컨테이너를 통해 개발팀은 앱에 집중하고, 운영팀은 인프라에 주력할 수 있습니다.    
 컨테이너 오케스트레이션은 엔터프라이즈 전반에서 이러한 배포를 관리할 수 있는 방법입니다.


<br>
- 클라우드 네이티브 애플리케이션은 탄력적으로 결합된 소규모의 독립적인 서비스 컬렉션입니다. 

이들 애플리케이션은 사용자 피드백을 신속하게 통합하여 지속적으로 개선할 수 있는 기능과 같은 비즈니스 가치를 제공할 수 있도록 설계되었습니다.

 다시 말해, 클라우드 네이티브 애플리케이션 개발은 새로운 애플리케이션을 구축하고, 기존 애플리케이션을 최적화하고, 모든 환경을 연결하는 작업을 가속화할 수 있는 방법입니다. 
 
 목표는 비즈니스 요구 사항의 변화 속도에 맞춰 사용자들이 원하는 애플리케이션을 제공하는 것입니다.

 <br>

 - 마이크로서비스란 소프트웨어를 구축하기 위한 아키텍처이자 하나의 접근 방식으로, 애플리케이션을 상호 독립적인 최소 구성 요소로 분할합니다.
 
  모든 요소를 하나의 애플리케이션에 구축하는 전통적인 모놀리식 접근 방식 대신 마이크로서비스에서는 모든 요소가 독립적이며 연동되어 동일한 태스크를 완수합니다. 
  
  이러한 각각의 구성 요소 또는 프로세스가 마이크로서비스입니다. 


<br>

사이트 신뢰성 엔지니어링(SRE)은 IT 운영에 대한 소프트웨어 엔지니어링 접근 방식입니다. 
 
SRE 팀은 소프트웨어를 툴로 활용하여 시스템을 관리하고, 문제를 해결하고, 운영 태스크를 자동화합니다.


SRE 팀은 기존에 운영 팀이 수동으로 하는 경우가 많았던 태스크를 받아 엔지니어 또는 운영 팀에 넘기고, 엔지니어 또는 운영 팀은 소프트웨어 및 자동화를 사용해 문제를 해결하고 프로덕션 시스템을 관리합니다. 

SRE는 확장 가능하고 신뢰성이 높은 소프트웨어 시스템을 생성할 때 유용한 방법입니다.

SRE 팀은 기존에 운영 팀이 수동으로 하는 경우가 많았던 태스크를 받아 엔지니어 또는 운영 팀에 넘기고, 엔지니어 또는 운영 팀은 소프트웨어 및 자동화를 사용해 문제를 해결하고 프로덕션 시스템을 관리합니다. 

SRE는 확장 가능하고 신뢰성이 높은 소프트웨어 시스템을 생성할 때 유용한 방법입니다.

SRE 팀은 코드의 배포, 설정, 모니터링 방식뿐만 아니라 프로덕션 환경에서 서비스 가용성, 대기 시간, 변경 관리, 비상 대응 및 용량 관리를 담당합니다.

SLI는 제공되는 서비스 수준의 특정 측면을 측정하기 위해 정의된 지표입니다.

주요 SLI에는 요청 대기 시간, 가용성, 오류 발생률 및 시스템 처리량이 포함됩니다. SLO는 SLI 기반 특정 서비스 수준에 대한 대상 값 또는 범위에 기반합니다.

그런 다음 허용 가능한 것으로 합의된 다운 타임에 따라 시스템의 신뢰성 요구 사항을 위한 SLO를 결정합니다. 

이 다운 타임 수준을 오차 할당(오류 및 중단에 허용되는 최대 임계값)이라고 합니다.  

SRE에서는 100% 신뢰성을 기대하지 않으며 장애에 대비해 계획을 마련합니다. 

개발 팀은 자동화된 오퍼레이션 테스트를 수행하여 신뢰성을 증명합니다. 

사이트 신뢰성 엔지니어는 운영 태스크 시간과 프로젝트 작업 시간을 구분합니다.



Google의 SRE 모범 사례에 따르면 사이트 신뢰성 엔지니어는 자기 시간의 최대 50%만 운영에 사용할 수 있으며 모니터링을 통해 이 시간을 초과하지 않도록 해야 합니다. 

이 시간을 초과하는 운영 작업 및 성능이 저하된 서비스는 사이트 신뢰성 엔지니어가 애플리케이션 또는 서비스 운영에 너무 많은 시간을 할애하지 않도록 개발 팀으로 다시 리디렉션된 후 실행될 수 있습니다. 


ㅁ Devops, SRE 비교

DevOps는 신속한 고품질 서비스 제공을 통해 비즈니스 가치와 대응력을 향상시키기 위한 기업 문화, 자동화, 플랫폼 설계에 대한 접근 방식입니다.

 SRE는 DevOps의 구현으로 간주될 수 있습니다.

 DevOps 및 SRE 모두 더 빠른 애플리케이션 개발 라이프사이클, 서비스 품질 및 신뢰성 개선, 개발되는 애플리케이션당 소요되는 IT 시간 단축 등의 이점을 달성할 수 있습니다.

SRE는 커뮤니케이션 및 워크플로우 문제를 해결할 때 운영 관련 경험이 있는 개발 팀의 사이트 신뢰성 엔지니어에 의존한다는 점이 다릅니다.

코드 및 새 기능의 측면에서 DevOps는 개발 파이프라인을 효율적으로 거치는 데 중점을 두는 반면, SRE는 사이트 신뢰성과 새로운 기능 개발 간 균형을 맞추는 데 중점을 둡니다. 



<br>

애플리케이션 라이프사이클 관리(Application Lifecycle Management, ALM)는 개념 구상에서 수명 종료 시까지 애플리케이션의 라이프사이클을 관리하는 인력, 툴, 프로세스를 뜻합니다.

ALM은 레거시 개발 프로세스에 따라 흔히 구분되는 몇 가지 분야로 구성되어 있습니다.

이러한 프로세스로 프로젝트 관리, 요구 사항 관리, 소프트웨어 개발, 테스트 및 품질 보증, 배포, 유지 관리 등을 포함하는 워터폴(Waterfall) 개발 방법을 들 수 있습니다. 

애플리케이션 라이프사이클 관리는 이러한 분야를 통합하고 팀이 조직을 위해 더 효율적으로 협업할 수 있도록 하여 애자일 및 DevOps 개발 접근 방식을 지원합니다. 

또한 ALM을 도입하면 잦은 릴리스(하루에 여러 번 가능한 경우도 있음)를 통해 소프트웨어와 업데이트를 지속적으로 제공할 수 있는데, 이는 새로운 릴리스가 몇 달 간격 또는 1년에 한 번 이루어지는 것과는 대조적인 방식입니다

ALM을 이용해 소프트웨어를 개발하는 경우에는 애플리케이션의 전체 수명을 고려해야 합니다. 애플리케이션의 사용을 종료하고 교체할 시기를 포함해 유지 관리 및 향후 업데이트를 고려해야 합니다. 

ALM을 이용하면 이 모든 것이 충족되어 더 빠른 배포, 워크플로우에 대한 가시성 향상, 제품의 품질 제고, 개발자 만족도 향상 등의 결과를 얻을 수 있습니다.



ㅁ ALM 단계    
: ALM은 개발 프로세스를 한눈에 파악하는 데 도움이 됩니다. 이 프로세스는 통합되어 있으므로 프로세스 진행 상황, 미완료 단계, 작업 소요 시간, 완료된 테스트 등을 알 수 있습니다.

1. 애플리케이션 거버넌스   
: 거버넌스란 애플리케이션에 관한 의사결정을 뜻합니다. 새로운 애플리케이션을 생성하는 프로세스를 시작할 때 애플리케이션에 대한 초기 아이디어로 시작하게 되는데, 이때 이 애플리케이션이 비즈니스 요구 사항 및 목표와 어떤 관련이 있는지도 고려해야 합니다.

이는 새 애플리케이션에 대한 요구 사항에 반영되는데, 이러한 요구 사항은 거버넌스 단계에서 정의되고 합의되어야 합니다. 

리소스 관리, 데이터 및 보안, 사용자 액세스는 애플리케이션 거버넌스를 구성하는 추가 요소입니다. 

이 프로세스를 표준화하면 거버넌스를 자동화할 수 있고, 이러한 거버넌스 프로세스를 자동화하면 애플리케이션 제공 속도가 빨라집니다.

2. 애플리케이션 개발   
: 애플리케이션 또는 업데이트에 대한 요구 사항이 간략히 제시되고 합의가 되면 개발을 시작할 수 있습니다. 애자일 방법론에 따른 개발을 선택한 팀은 매일 한 번에서 여러 번까지 개발하고 배포할 수 있습니다. 

애플리케이션 설계, 빌드, 테스트 및 배포는 모두 개발 단계의 일부로 간주될 수 있습니다.

3. 소프트웨어 테스트   
: 새 애플리케이션을 개발했으면 테스트를 거쳐 버그를 해결한 후에 프로덕션 단계로 진행해야 합니다. 

애자일 및 DevOps 팀의 경우 개발과 동시에 테스트를 진행해야 합니다. 피드백은 개발 팀에 지속적으로 전달되어야 합니다. 

지속적 통합을 개발 프로세스에 포함하여 이처럼 빈번한 업데이트가 서로 충돌하지 않게 해야 합니다. 

테스트 단계의 목표는 애플리케이션을 사용자에게 릴리스하기 전에 거버넌스에 기반한 요구 사항이 충족되었는지, 그리고 애플리케이션이 제대로 작동하는지 확인하는 것입니다.

4. 운영 및 유지 관리   
: 테스트를 완료하고 버그를 수정한 후에 애플리케이션을 사용자에게 배포할 수 있습니다. 

운영 및 유지 관리 단계에서는 ALM을 애플리케이션의 전체 수명에 집중합니다. 애플리케이션이 배포되었다고 해서 운영이 끝나는 것은 아닙니다. 정기적인 유지관리와 업데이트를 고려해야 합니다. 

애플리케이션 또는 서비스의 사용 종료도 유지 관리의 일부로 간주해야 합니다. 팀은 애플리케이션에 대한 지원을 중단하거나 새 버전을 제공할 시점을 정의해야 합니다.


ㅁ ALM과 SDLC 비교

SDLC가 기본적으로 개발 단계에 중점을 두는 반면, ALM은 개념에서 유지 관리를 거쳐 결국 제거에 이르는 전체 애플리케이션 라이프사이클을 고려하므로 애플리케이션 개발 후에도 지속된다는 것입니다. 

SDLC는 애플리케이션 라이프사이클 관리의 일부로 간주될 수 있는데, 주로 개발, 테스트 및 배포 단계가 이에 해당합니다. ALM에는 특정 애플리케이션에 대한 몇 개의 개발 라이프사이클이 포함될 수 있습니다.


ㅁ 프로비저닝

프로비저닝은 IT 인프라를 설정하는 프로세스입니다. 또한 사용자와 시스템에서 사용할 수 있도록, 데이터와 리소스에 대한 액세스를 관리하는 데 필요한 단계를 지칭하기도 합니다. 

프로비저닝과 설정은 각기 다른 작업이지만, 둘 다 배포 프로세스의 단계에 포함되며 일단 프로비저닝이 완료되어야 설정 단계를 진행할 수 있습니다.

ㅁ 프로비저닝 유형

1. 서버 프로비저닝   
: 서버 프로비저닝은 필요한 리소스를 기반으로 네트워크에서 사용될 서버를 설정하는 프로세스입니다. 

새로운 시스템을 생성한 후 가동 상태로 만드는 데 필요한 모든 작업은 물론, 해당 시스템에 대해 원하는 상태를 정의하는 작업도 포함됩니다.

서버 프로비저닝은 데이터센터에 물리적 하드웨어 설치, 소프트웨어 설치 및 설정, 운영 체제 및 애플리케이션 포함, 미들웨어와 네트워크 및 스토리지 연결로 이루어집니다. 

2. 사용자 프로비저닝   
: 사용자 프로비저닝은 액세스 권한과 인증 권한을 모니터링하는 아이덴티티 관리 유형에 속합니다. 프로비저닝은 직원, 공급업체, 계약자와 같은 사용자 오브젝트와 사용자 속성을 통해 정의됩니다. 제공되는 서비스에는 이메일, 데이터베이스 액세스, 네트워크 액세스가 포함될 수 있습니다. 

롤 기반 액세스 제어(Role-Based Access Control, RBAC) 설정은 사용자 프로비저닝의 예입니다. 일반적으로 RBAC는 권한, 롤, 그룹, 사용자로 구성됩니다.

사용자는 하나 이상의 그룹에 할당되고, 그룹에는 롤(예: 읽기 전용, 편집, 관리자)이 할당되며, 롤은 권한으로 구성되는 식입니다.

사용자 프로비저닝은 IT와 HR 사이에서 관리되는 경우가 많습니다.

3. 네트워크 프로비저닝   
: 네트워크 프로비저닝에는 특히 사용자, 서버, 컨테이너, IoT 기기가 액세스할 네트워크를 설정하는 작업이 포함될 수 있습니다. 오늘날의 연결된 세상에서는 다양한 항목 유형이 네트워크 소비자일 수 있습니다.  

네트워크 프로비저닝은 필요한 장비와 배선을 비롯해 사용자에게 통신 서비스를 제공하는 것을 지칭하는 방식으로 흔히 통신 업계에서 사용되며, 사용자를 위한 무선 환경의 서비스 활성화를 포함할 수도 있습니다. 

4. 서비스 프로비저닝   
: 서비스 프로비저닝에는 서비스 설정과 이와 관련된 데이터 관리가 포함됩니다. 서비스 프로비저닝은 통신 업계에서 고객을 위한 서비스나 클라우드 인프라를 설정하는 데 사용됩니다. 

예를 들어 클라우드 서비스 프로비저닝은 클라우드 컴퓨팅의 셀프 서비스 구성 요소입니다. 사용자는 IT 직원의 도움 없이도 셀프 서비스 포털을 통해 클라우드 서비스를 사용할 수 있습니다.



ㅁ 프로비저닝 자동화 필요한 이유

개발자는 여전히 새로운 배포 각각에 대해 가상 인프라를 프로비저닝해야 하며, 수동 프로비저닝은 시간이 많이 소요되고 인적 오류가 발생할 확률이 큽니다. 

각 배포에 대해 개발자가 직접 프로비저닝을 관리해야 하는 경우 변경 사항을 추적하고, 버전을 관리하며, 오류를 방지하고 일관성을 맞추기가 어렵습니다.

코드형 인프라(Infrastructure as code, IaC)는 인프라 자동화를 지원하는 솔루션을 제공합니다. 

IaC는 수동 프로세스가 아닌 코드를 통해 인프라를 관리하고 프로비저닝합니다. 

IaC로 인프라 프로비저닝을 자동화하면 애플리케이션을 개발하거나 배포할 때마다 개발자가 직접 서버, 운영 체제, 스토리지, 기타 인프라 구성 요소를 수동으로 프로비저닝하고 관리할 필요가 없어집니다. 

IaC를 사용하면 인프라 사양이 포함된 설정 파일이 생성됩니다. 덕분에 개발자의 주요 프로비저닝 작업이 간편해지므로 인프라 가동을 준비하려면 스크립트만 실행하면 됩니다. 

IaC는 매번 동일한 환경을 프로비저닝하도록 보장합니다.

코드로 인프라를 배포한다는 것은 인프라를 모듈식 구성 요소로 분할해 자동화를 통해 다양한 방식으로 결합할 수 있다는 뜻이기도 합니다. 

인프라를 코드화하면 프로비저닝할 때 따라야 할 템플릿이 생깁니다